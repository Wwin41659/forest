searchState.loadedDescShard("fil_actors_shared", 0, "Convenience macro for generating Actor Errors\nConvenience macro for generating Actor Errors\nConvenience macro for generating Actor Errors\nConvenience macro for generating Actor Errors\nConvenience macro for generating Actor Errors\nConvenience macro for generating Actor Errors\nConvenience macro for generating Actor Errors\nComputes an unsealed sector CID (<code>CommD</code>) from its …\nLotus compatibility layer.\nArray type used within actors. The underlying type is an …\nDeal weight\nThe expected number of block producers in each epoch.\nMap type to be used within actors. The underlying type is …\nCreate a HAMT with a custom bit-width.\nCreate a map with a root Cid.\nCreate a map with a root Cid.\nThe error type returned by actor method calls.\nReturns the exit code of the error.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nError message of the actor error.\nCreates a new <code>ActorError</code>. This method does not check that …\nPrefix error message with a string message.\nThe expected number of block producers in each epoch.\nDefines first available ID address after builtin actors\nSpecifies a domain for randomness generation.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIdentifies the builtin actor types for usage with the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe maximum number of partitions that may be required to …\nThe maximum number of sector infos that may be required to …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nRatio of sector size to maximum deals per sector. The …\nThe number of blocks between payouts for deals\nMaximum number of unique “declarations” in batch …\nThe delay between pre-commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe default duration after a verified deal’s nominal …\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum number of control addresses a miner may register.\n<code>MaxMultiaddrData</code> is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\n<code>MaxPeerIDLength</code> is the maximum length allowed for any …\nMaximum total replica update proof size.\nMaximum number of epochs past the current epoch a sector …\nMaximum time a verified allocation can be active without …\nMaximum term for a verified data allocation (epochs)\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nMinimum miner consensus power\nMinimum verified deal size\nMinimum term for a verified data allocation (epochs)\nThe maximum number of new sectors that may be staged by a …\nNumber of epochs between publishing the pre-commit and …\nThe maximum number of sector pre-commitments in a single …\nDenominator of the percentage of normalized circulating …\nNumerator of the percentage of normalized circulating …\nThe maximum number of sector replica updates in a single …\nThe maximum number of sectors that a miner can have …\nAllowed post proof types for new miners\nAllowed pre-commit proof types for new miners\nStaging period for a miner worker key change. Finality is …\nLook-back from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\n<code>WPoStDisputeWindow</code> is the period after a challenge window …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nThe maximum number of partitions that may be required to …\nThe maximum number of sector infos that may be required to …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nRatio of sector size to maximum deals per sector. The …\n<code>DealUpdatesInterval</code> is the number of blocks between …\nMaximum number of unique “declarations” in batch …\nThe delay between pre-commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum number of control addresses a miner may register.\n<code>MaxMultiaddrData</code> is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\n<code>MaxPeerIDLength</code> is the maximum length allowed for any …\nMaximum total aggregated proof size.\nMaximum number of epochs past the current epoch a sector …\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nThe maximum number of new sectors that may be staged by a …\nNumber of epochs between publishing the pre-commit and …\nThe maximum number of sector pre-commitments in a single …\nThe maximum number of sector replica updates in a single …\nDenominator of the percentage of normalized circulating …\nNumerator of the percentage of normalized circulating …\nThe maximum number of sectors that a miner can have …\nStaging period for a miner worker key change. Finality is …\nLookback from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nTrait to allow multiple error types to be able to be …\n<code>Multimap</code> stores multiple values per key in a HAMT of AMTs. …\nSet is a HAMT with empty values for the purpose of acting …\n<code>SetMultimap</code> is a HAMT with values that are also a HAMT but …\nAdds a value for a key.\nCollects all keys from the set into a vector.\nDeletes key from set.\nDowncast a dynamic std Error into an <code>ActorError</code>. If the …\nWrap the error with a message, without overwriting an exit …\nIterates through all arrays in the <code>Multimap</code>\nIterates through all values in the array at a given key.\nIterates through keys and converts them to a <code>DealID</code> to …\nIterates through all keys in the set.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes a <code>Multimap</code> from a root Cid\nInitializes a <code>SetMultimap</code> from a root Cid.\nInitializes a Set from a root Cid.\nGets the Array of value type <code>V</code> using the <code>Multimap</code> store.\nGets the set at the given index of the <code>SetMultimap</code>\nChecks if key exists in the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a new empty <code>Multimap</code>. The <code>outer_bitwidth</code> is …\nInitializes a new empty <code>SetMultimap</code>.\nInitializes a new empty Set with the default bit-width.\nInitializes a new empty Set given a bit-width.\nPuts the <code>DealID</code> in the hash set of the key.\nAdds key to the set.\nPuts slice of <code>DealID</code>s in the hash set of the key.\nRemoves a key from the <code>MapMap</code>, returning the value at the …\nRemoves a <code>DealID</code> from a key hash set.\nRemoves all values for a key.\nRemoves set at index.\nRetrieve root from the <code>Multimap</code>.\nRetrieve root from the <code>SetMultimap</code>.\nRetrieve root from the Set.\nArray type used within actors. The underlying type is an …\nDeal weight\nThe expected number of block producers in each epoch.\nMap type to be used within actors. The underlying type is …\nCreate a hamt with a custom bitwidth.\nCreate a map with a root cid.\nCreate a map with a root cid.\nThe error type returned by actor method calls.\nCreates a new ActorError. This method checks if the exit …\nReturns the exit code of the error.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nError message of the actor error.\nExtracts the optional associated data without copying.\nCreates a new ActorError. This method does not check that …\nPrefix error message with a string message.\nThe expected number of block producers in each epoch.\nDefines first available ID address after builtin actors\nSpecifies a domain for randomness generation.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIdentifies the builtin actor types for usage with the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA set indicating which proofs are considered valid, …\nThe maximum number of partitions that may be required to …\nThe maximum number of sector infos that may be required to …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nChecks if the requested proof type exists in the set\nRatio of sector size to maximum deals per sector. The …\nThe number of blocks between payouts for deals\nMaximum number of unique “declarations” in batch …\nCreate a <code>ProofSet</code> for enabled <code>RegisteredPoStProof</code>s\nCreate a <code>ProofSet</code> for enabled <code>RegisteredSealProof</code>s\nThe delay between pre commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds the requested proof type to the set of valid proofs\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe default duration after a verified deal’s nominal …\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum number of control addresses a miner may register.\nMaxMultiaddrData is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\nMaxPeerIDLength is the maximum length allowed for any …\nMaximum total replica update proof size.\nMaximum number of epochs past the current epoch a sector …\nMaximum time a verified allocation can be active without …\nMaximum term for a verified data allocaion (epochs)\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nMinimum miner consensus power\nMinimum verified deal size\nMinimum term for a verified data allocation (epochs)\nThe maximum number of new sectors that may be staged by a …\nNumber of epochs between publishing the precommit and when …\nThe maximum number of sector pre-commitments in a single …\nDenominator of the percentage of normalized cirulating …\nNumerator of the percentage of normalized cirulating …\nThe maximum number of sector replica updates in a single …\nThe maximum number of sectors that a miner can have …\nAllowed post proof types for new miners\nAllowed pre commit proof types for new miners\nStaging period for a miner worker key change. Finality is …\nLookback from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\nWPoStDisputeWindow is the period after a challenge window …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nThe maximum number of partitions that may be required to …\nThe maximum number of sector infos that may be required to …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nRatio of sector size to maximum deals per sector. The …\nDealUpdatesInterval is the number of epochs between …\nMaximum number of unique “declarations” in batch …\nThe delay between pre commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum number of control addresses a miner may register.\nMaxMultiaddrData is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\nMaxPeerIDLength is the maximum length allowed for any …\nMaximum total aggregated proof size.\nMaximum number of epochs past the current epoch a sector …\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nThe maximum number of new sectors that may be staged by a …\nNumber of epochs between publishing the precommit and when …\nThe maximum number of sector pre-commitments in a single …\nThe maximum number of sector replica updates in a single …\nDenominator of the percentage of normalized cirulating …\nNumerator of the percentage of normalized cirulating …\nThe number of total possible types (enum variants) of …\nThe number of total possible types (enum variants) of …\nThe maximum number of sectors that a miner can have …\nStaging period for a miner worker key change. Finality is …\nLookback from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nTrait to allow multiple error types to be able to be …\nMultimap stores multiple values per key in a Hamt of Amts. …\nSet is a Hamt with empty values for the purpose of acting …\nSetMultimap is a hamt with values that are also a hamt but …\nAdds a value for a key.\nCollects all keys from the set into a vector.\nDeletes key from set.\nDowncast a dynamic std Error into an <code>ActorError</code>. If the …\nWrap the error with a message, without overwriting an exit …\nIterates through all arrays in the multimap\nIterates through all values in the array at a given key.\nIterates through keys and converts them to a DealID to …\nIterates through all keys in the set.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes a multimap from a root Cid\nInitializes a SetMultimap from a root Cid.\nInitializes a Set from a root Cid.\nGets the Array of value type <code>V</code> using the multimap store.\nGets the set at the given index of the <code>SetMultimap</code>\nChecks if key exists in the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a new empty multimap. The outer_bitwidth is …\nInitializes a new empty SetMultimap.\nInitializes a new empty Set with the default bitwidth.\nInitializes a new empty Set given a bitwidth.\nPuts the DealID in the hash set of the key.\nAdds key to the set.\nPuts slice of DealIDs in the hash set of the key.\nRemoves a key from the MapMap, returning the value at the …\nRemoves a DealID from a key hash set.\nRemoves all values for a key.\nRemoves set at index.\nRetrieve root from the multimap.\nRetrieve root from the SetMultimap.\nRetrieve root from the Set.\nArray type used within actors. The underlying type is an …\nDeal weight\nThe expected number of block producers in each epoch.\nMap type to be used within actors. The underlying type is …\nCreate a hamt with a custom bitwidth.\nCreate a map with a root cid.\nCreate a map with a root cid.\nThe error type returned by actor method calls.\nCreates a new ActorError. This method checks if the exit …\nReturns the exit code of the error.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nError message of the actor error.\nExtracts the optional associated data without copying.\nCreates a new ActorError. This method does not check that …\nPrefix error message with a string message.\nThe expected number of block producers in each epoch.\nDefines first available ID address after builtin actors\nSpecifies a domain for randomness generation.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIdentifies the builtin actor types for usage with the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA set indicating which proofs are considered valid, …\nThe maximum number of partitions that may be required to …\nThe maximum number of sector infos that may be required to …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nChecks if the requested proof type exists in the set\nRatio of sector size to maximum deals per sector. The …\nThe number of blocks between payouts for deals\nMaximum number of unique “declarations” in batch …\nCreate a <code>ProofSet</code> for enabled <code>RegisteredPoStProof</code>s\nCreate a <code>ProofSet</code> for enabled <code>RegisteredSealProof</code>s\nThe delay between pre commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds the requested proof type to the set of valid proofs\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe default duration after a verified deal’s nominal …\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum number of control addresses a miner may register.\nMaxMultiaddrData is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\nMaxPeerIDLength is the maximum length allowed for any …\nMaximum total replica update proof size.\nMaximum number of epochs past the current epoch a sector …\nMaximum time a verified allocation can be active without …\nMaximum term for a verified data allocaion (epochs)\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nMinimum miner consensus power\nMinimum verified deal size\nMinimum term for a verified data allocation (epochs)\nThe maximum number of new sectors that may be staged by a …\nThe maximum number of partitions that can be proven in a …\nNumber of epochs between publishing the precommit and when …\nThe maximum number of sector pre-commitments in a single …\nDenominator of the percentage of normalized cirulating …\nNumerator of the percentage of normalized cirulating …\nThe maximum number of sector replica updates in a single …\nThe maximum number of sectors that a miner can have …\nAllowed post proof types for new miners\nAllowed pre commit proof types for new miners\nStaging period for a miner worker key change.\nLookback from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\nWPoStDisputeWindow is the period after a Window PoSt …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nThis is a conservative value that is chosen via …\nA value (2^27) limits 32GiB sectors to 256 deals and 64GiB …\nTrait to allow multiple error types to be able to be …\nWraps a HAMT to provide a convenient map API. Any errors …\nMultimap stores multiple values per key in a Hamt of Amts. …\nSet is a Hamt with empty values for the purpose of acting …\nSetMultimap is a hamt with values that are also a hamt but …\nAdds a value for a key.\nThe <code>bit_width</code> drives how wide and high the tree is going …\nReturns a vector of exit codes for each item (including …\nCollects all keys from the set into a vector.\nDeletes key from set.\nDowncast a dynamic std Error into an <code>ActorError</code>. If the …\nWrap the error with a message, without overwriting an exit …\nCreates a new, empty map.\nFlushes the map’s contents to the store. Returns the …\nCreates a new empty map and flushes it to the store. …\nIterates through all arrays in the multimap\nIterates over all key-value pairs in the map.\nIterates through all values in the array at a given key.\nIterates through keys and converts them to a DealID to …\nIterates through all keys in the set.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes a multimap from a root Cid\nInitializes a SetMultimap from a root Cid.\nInitializes a Set from a root Cid.\nReturns a reference to the value associated with a key, if …\nGets the Array of value type <code>V</code> using the multimap store.\nGets the set at the given index of the <code>SetMultimap</code>\nChecks if key exists in the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoads a map from the store.\nMaximum number of key-value pairs in a bucket before it’…\nThe minimum depth at which the HAMT can store key-value …\nInitializes a new empty multimap. The outer_bitwidth is …\nInitializes a new empty SetMultimap.\nInitializes a new empty Set with the default bitwidth.\nInitializes a new empty Set given a bitwidth.\nPuts the DealID in the hash set of the key.\nAdds key to the set.\nPuts slice of DealIDs in the hash set of the key.\nRemoves a key from the MapMap, returning the value at the …\nRemoves a DealID from a key hash set.\nRemoves all values for a key.\nRemoves set at index.\nRetrieve root from the multimap.\nRetrieve root from the SetMultimap.\nRetrieve root from the Set.\nInserts a key-value pair into the map. Returns any value …\nInserts a key-value pair only if the key does not already …\nReturns a subset of items corresponding to the successful …\nArray type used within actors. The underlying type is an …\nDeal weight\nThe expected number of block producers in each epoch.\nMap type to be used within actors. The underlying type is …\nCreate a hamt with a custom bitwidth.\nCreate a map with a root cid.\nCreate a map with a root cid.\nThe error type returned by actor method calls.\nCreates a new ActorError. This method checks if the exit …\nReturns the exit code of the error.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nError message of the actor error.\nExtracts the optional associated data without copying.\nCreates a new ActorError. This method does not check that …\nPrefix error message with a string message.\nThe expected number of block producers in each epoch.\nDefines first available ID address after builtin actors\nSpecifies a domain for randomness generation.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA set indicating which proofs are considered valid, …\nThe maximum number of partitions that may be required to …\nThe maximum number of sector infos that may be required to …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nChecks if the requested proof type exists in the set\nRatio of sector size to maximum deals per sector. The …\nThe number of blocks between payouts for deals\nMaximum number of unique “declarations” in batch …\nCreate a <code>ProofSet</code> for enabled <code>RegisteredPoStProof</code>s\nCreate a <code>ProofSet</code> for enabled <code>RegisteredSealProof</code>s\nThe delay between pre commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds the requested proof type to the set of valid proofs\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe default duration after a verified deal’s nominal …\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum number of control addresses a miner may register.\nMaxMultiaddrData is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\nMaxPeerIDLength is the maximum length allowed for any …\nMaximum total replica update proof size.\nMaximum number of epochs past the current epoch a sector …\nMaximum time a verified allocation can be active without …\nMaximum term for a verified data allocaion (epochs)\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nMinimum miner consensus power\nMinimum verified deal size\nMinimum term for a verified data allocation (epochs)\nThe maximum number of new sectors that may be staged by a …\nThe maximum number of partitions that can be proven in a …\nNumber of epochs between publishing the precommit and when …\nThe maximum number of sector pre-commitments in a single …\nDenominator of the percentage of normalized cirulating …\nNumerator of the percentage of normalized cirulating …\nThe maximum number of sector replica updates in a single …\nThe maximum number of sectors that a miner can have …\nAllowed post proof types for new miners\nAllowed pre commit proof types for new miners\nStaging period for a miner worker key change.\nLookback from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\nWPoStDisputeWindow is the period after a Window PoSt …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nThis is a conservative value that is chosen via …\nA value (2^27) limits 32GiB sectors to 256 deals and 64GiB …\nTrait to allow multiple error types to be able to be …\nBuilder for ActorEvent objects, accumulating key/value …\nWraps a HAMT to provide a convenient map API. Any errors …\nAccumulates a sequence of messages (e.g. validation …\nMultimap stores multiple values per key in a Hamt of Amts. …\nSet is a Hamt with empty values for the purpose of acting …\nSetMultimap is a hamt with values that are also a hamt but …\nAdds a value for a key.\nAdds a message to the accumulator\nAdds messages from another accumulator to this one\nPanic if the accumulator isn’t empty. The acculumated …\nAsserts the accumulator contains messages matching …\nThe <code>bit_width</code> drives how wide and high the tree is going …\nReturns an actor event ready to emit (consuming self).\nReturns a vector of exit codes for each item (including …\nCollects all keys from the set into a vector.\nDeletes key from set.\nDowncast a dynamic std Error into an <code>ActorError</code>. If the …\nWrap the error with a message, without overwriting an exit …\nCreates a new, empty map.\nPushes an entry with an indexed key and an un-indexed, …\nPushes an entry with an indexed key and indexed, …\nFlushes the map’s contents to the store. Returns the …\nCreates a new empty map and flushes it to the store. …\nIterates through all arrays in the multimap\nIterates over all key-value pairs in the map.\nIterates through all values in the array at a given key.\nIterates through keys and converts them to a DealID to …\nIterates through all keys in the set.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes a multimap from a root Cid\nInitializes a SetMultimap from a root Cid.\nInitializes a Set from a root Cid.\nReturns a reference to the value associated with a key, if …\nGets the Array of value type <code>V</code> using the multimap store.\nGets the set at the given index of the <code>SetMultimap</code>\nChecks if key exists in the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the map is empty.\nReturns the number of accumulated messages\nLoads a map from the store.\nMaximum number of key-value pairs in a bucket before it’…\nThe minimum depth at which the HAMT can store key-value …\nCreates a new builder with no values.\nInitializes a new empty multimap. The outer_bitwidth is …\nInitializes a new empty SetMultimap.\nInitializes a new empty Set with the default bitwidth.\nInitializes a new empty Set given a bitwidth.\nPuts the DealID in the hash set of the key.\nAdds key to the set.\nPuts slice of DealIDs in the hash set of the key.\nRemoves a key from the MapMap, returning the value at the …\nRemoves a DealID from a key hash set.\nRemoves all values for a key.\nRemoves set at index.\nAdds a message if predicate is false\nAdds a message if result is <code>Err</code>. Underlying error must be …\nRetrieve root from the multimap.\nRetrieve root from the SetMultimap.\nRetrieve root from the Set.\nInserts a key-value pair into the map. Returns any value …\nInserts a key-value pair only if the key does not already …\nComputes a batch return that is the result of a sequence …\nReturns a subset of items corresponding to the successful …\nInitialise the “type” of the event i.e. Actor event …\nReturns a new accumulator backed by the same collection, …\nDeserialises CBOR-encoded bytes as a structure, returning …\nDeserialises CBOR-encoded bytes as a method parameters …\nSerializes a structure as CBOR bytes, returning a …\nSerializes a structure as a CBOR vector of bytes, …\nPure functions implemented as primitives by the runtime.\nAn abstract VM that is injected into integration tests\nGet information about an actor\nReturn a map of actor code CIDs to their corresponding …\nReturns a map of all actor addresses to their …\nGet the balance of the specified actor\nTokens available to the actor.\nGet the current base fee\nReturns the underlying blockstore of the VM\nGet the circulating supply constant for the network\nLink to code for the actor.\nComputes an unsealed sector CID (CommD) from its …\nThe actor’s “delegated” address, if assigned.\nGet the current chain epoch\nSend a message between the two specified actors\nSend a message without charging gas\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHashes input data using a supported hash function.\nHashes input into a 64 byte buffer\nHashes input data using blake2b with 256 bit output.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProvides access to VM primitives that can be mocked\nOverride the primitive batch_verify_seals function\nOverride the primitive compute_unsealed_sector_cid function\nOverride the primitive hash function\nOverride the primitive hash_64 function\nOverride the primitive hash_blake2b function\nOverride the primitive recover_secp_public_key function\nOverride the primitive verify_aggregate_seals function\nOverride the primitive verify_consensus_fault function\nOverride the primitive verify_post function\nOverride the primitive verify_replica_update function\nOverride the primitive verify_signature function\nProvides access to VM primitives\nGet the ID for the specified address\nSequence of the actor.\nUpsert an actor into the state tree\nSet the current base fee\nSet the circulating supply constant for the network\nSets the epoch to the specified value\nSet the current timestamp\nLink to the state of the actor.\nTake all the invocations that have been made since the …\nGet the current timestamp\nVerifies that two block headers provide proof of a …\nVerifies a window proof of spacetime.\nVerifies that a signature is valid for an address and …\nIdentifies the builtin actor types for usage with the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn expectation for a method invocation trace. Non-optional …\nA trace of an actor method invocation.\nerror_number is set when an unexpected syscall error occurs\nIf error_number is set, exit_code and return_value are not …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAsserts that a trace matches this expectation, including …\nArray type used within actors. The underlying type is an …\nDeal weight\nMap type to be used within actors. The underlying type is …\nCreate a hamt with a custom bitwidth.\nCreate a map with a root cid.\nThe error type returned by actor method calls.\nCreates a new ActorError. This method checks if the exit …\nReturns the exit code of the error.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nError message of the actor error.\nExtracts the optional associated data without copying.\nCreates a new ActorError. This method does not check that …\nPrefix error message with a string message.\nAssumed epoch duration. If this changes, a large …\nThis is a protocol constant from Filecoin and depends on …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\npolyval evaluates a polynomial given by coefficients <code>p</code> in …\nReturns the Q.0 position estimate of the filter\nExtrapolate filter “position” delta epochs in the …\nExtrapolate the CumSumRatio given two filters.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new filter estimate given two Q.0 format ints.\nAn error returned on a failed send. Can be automatically …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nResolveToActorID resolves the given address to its actor …\nDefines first available ID address after builtin actors\nSpecifies a domain for randomness generation.\nMessage information available to the actor about executing …\nRuntime is the VM’s internal runtime object. this is …\nThe balance of an actor.\nReturns the gas base fee (cost per unit) for the current …\nThe address of the immediate calling actor. Always an …\nThe ID for this chain. Filecoin chain IDs are usually in …\nChargeGas charges specified amount of <code>gas</code> for execution. …\nInitializes the state object. This is only valid when the …\nCreates an actor with code <code>codeID</code>, an empty state, id …\nThe current chain epoch number, corresponding to the epoch …\nThe balance of the receiver.\nDeletes the executing actor from the state tree. Fails if …\nEmits an event denoting that something externally …\nReturns the argument unchanged.\nThe gas still available for computation\nThe message gas premium\nLook up the code ID at an actor address.\nReturns the CodeCID for a built-in actor type. The kernel …\nRandomness returns a (pseudo)random byte array drawing …\nRandomness returns a (pseudo)random byte array drawing …\nGets the state-root.\nCalls <code>U::from(self)</code>.\nLooks up the “delegated” address of an actor by ID, if …\nInformation related to the current message being executed.\nThe network protocol version number at the current epoch.\nComputes an address for a new actor. The returned address …\nThe nonce of the currently executing message.\nThe address of the origin of the current invocation. …\nReturns true if the call is read_only. All state updates, …\nThe address of the actor receiving the message. Always an …\nResolves an address of any protocol to an ID address (via …\nReturns whether the specified CodeCID belongs to a …\nSends a message to another actor, returning the exit code …\nSimplified version of <code>Runtime::send</code> that does not specify …\nSets the state-root.\nLoads a readonly copy of the state of the receiver into …\nReturns reference to blockstore\nThe CID of the tipset at the specified epoch. The epoch …\nThe timestamp of the tipset at the current epoch (see …\nReturns the total token supply in circulation at the …\nLoads a mutable copy of the state of the receiver, passes …\nValidates the caller against some predicate. Exported …\nValidates that the caller has a delegated address that is …\nThe value attached to the message being processed, …\nA set indicating which proofs are considered valid, …\nThe maximum number of partitions that may be required to …\nThe maximum number of sector numbers addressable in a …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nChecks if the requested proof type exists in the set\nRatio of sector size to maximum deals per sector. The …\nThe number of blocks between payouts for deals\nMaximum number of unique “declarations” in batch …\nCreate a <code>ProofSet</code> for enabled <code>RegisteredPoStProof</code>s\nCreate a <code>ProofSet</code> for enabled <code>RegisteredSealProof</code>s\nThe delay between pre commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds the requested proof type to the set of valid proofs\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe default duration after a verified deal’s nominal …\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum amount of sectors that can be aggregated in NI …\nMaximum number of control addresses a miner may register.\nMaxMultiaddrData is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\nMaxPeerIDLength is the maximum length allowed for any …\nNumber of epochs between publishing the commit and when …\nMaximum total replica update proof size.\nMaximum number of epochs past the current epoch a sector …\nMaximum time a verified allocation can be active without …\nMaximum term for a verified data allocaion (epochs)\nMinimum amount of sectors that can be aggregated.\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nMinimum miner consensus power\nMinimum verified deal size\nMinimum term for a verified data allocation (epochs)\nThe maximum number of new sectors that may be staged by a …\nThe maximum number of partitions that can be proven in a …\nNumber of epochs between publishing the precommit and when …\nThe maximum number of sector pre-commitments in a single …\nDenominator of the percentage of normalized cirulating …\nNumerator of the percentage of normalized cirulating …\nThe maximum number of sector replica updates in a single …\nThe maximum number of sectors that a miner can have …\nAllowed post proof types for new miners\nAllowed pre commit proof types for new miners\nAllowed non interactive proof types for new miners\nStaging period for a miner worker key change.\nLookback from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\nWPoStDisputeWindow is the period after a Window PoSt …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nThis is a conservative value that is chosen via …\nA value (2^27) limits 32GiB sectors to 256 deals and 64GiB …\nThe maximum assignable sector number. Raising this would …\nTrait to allow multiple error types to be able to be …\nBuilder for ActorEvent objects, accumulating key/value …\nWraps a HAMT to provide a convenient map API. Any errors …\nAccumulates a sequence of messages (e.g. validation …\nMultimap stores multiple values per key in a Hamt of Amts. …\nSet is a HAMT with empty values.\nSetMultimap is a HAMT with values that are also a HAMT …\nAdds a value for a key.\nAdds a message to the accumulator\nAdds messages from another accumulator to this one\nPanic if the accumulator isn’t empty. The acculumated …\nAsserts the accumulator contains messages matching …\nThe <code>bit_width</code> drives how wide and high the tree is going …\nReturns an actor event ready to emit (consuming self).\nReturns a vector of exit codes for each item (including …\nCollects all keys from the set into a vector.\nDeletes key from set.\nDowncast a dynamic std Error into an <code>ActorError</code>. If the …\nWrap the error with a message, without overwriting an exit …\nCreates a new, empty map.\nInitializes a new empty Set with the default bitwidth.\nInitializes a new empty SetMultimap.\nPushes an entry with an indexed key and an un-indexed, …\nPushes an entry with an indexed key and indexed, …\nFlushes the map’s contents to the store. Returns the …\nRetrieve root from the Set.\nRetrieve root from the SetMultimap.\nCreates a new empty map and flushes it to the store. …\nIterates through all arrays in the multimap\nIterates over all key-value pairs in the map.\nIterates through all values in the array at a given key.\nIterates through all keys in the set.\nIterates over all keys.\nIterates values for a key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes a multimap from a root Cid\nReturns a reference to the value associated with a key, if …\nGets the Array of value type <code>V</code> using the multimap store.\nGets the set of values for a key.\nChecks if key exists in the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the map is empty.\nReturns the number of accumulated messages\nLoads a map from the store.\nInitializes a Set from a root Cid.\nInitializes a SetMultimap from a root Cid.\nMaximum number of key-value pairs in a bucket before it’…\nThe minimum depth at which the HAMT can store key-value …\nCreates a new builder with no values.\nInitializes a new empty multimap. The outer_bitwidth is …\nAdds key to the set.\nPuts a value in the set associated with a key.\nPuts slice of values in the hash set associated with a key.\nRemoves a key from the MapMap, returning the value at the …\nRemoves a value from the set associated with a key, if it …\nRemoves all values for a key.\nRemoves set at index.\nAdds a message if predicate is false\nAdds a message if result is <code>Err</code>. Underlying error must be …\nRetrieve root from the multimap.\nInserts a key-value pair into the map. Returns any value …\nInserts a key-value pair only if the key does not already …\nComputes a batch return that is the result of a sequence …\nReturns a reference to the underlying blockstore.\nReturns a subset of items corresponding to the successful …\nInitialise the “type” of the event i.e. Actor event …\nReturns a new accumulator backed by the same collection, …\nDeserialises CBOR-encoded bytes as a structure, returning …\nDeserialises CBOR-encoded bytes as a method parameters …\nSerializes a structure as CBOR bytes, returning a …\nSerializes a structure as a CBOR vector of bytes, …\nPure functions implemented as primitives by the runtime.\nAn abstract VM that is injected into integration tests\nGet information about an actor\nReturn a map of actor code CIDs to their corresponding …\nReturns a map of all actor addresses to their …\nGet the balance of the specified actor\nTokens available to the actor.\nGet the current base fee\nReturns the underlying blockstore of the VM\nGet the circulating supply constant for the network\nLink to code for the actor.\nComputes an unsealed sector CID (CommD) from its …\nThe actor’s “delegated” address, if assigned.\nGet the current chain epoch\nSend a message between the two specified actors\nSend a message without charging gas\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHashes input data using a supported hash function.\nHashes input into a 64 byte buffer\nHashes input data using blake2b with 256 bit output.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProvides access to VM primitives that can be mocked\nOverride the primitive batch_verify_seals function\nOverride the primitive compute_unsealed_sector_cid function\nOverride the primitive hash function\nOverride the primitive hash_64 function\nOverride the primitive hash_blake2b function\nOverride the primitive recover_secp_public_key function\nOverride the primitive verify_aggregate_seals function\nOverride the primitive verify_consensus_fault function\nOverride the primitive verify_post function\nOverride the primitive verify_replica_update function\nOverride the primitive verify_signature function\nProvides access to VM primitives\nGet the ID for the specified address\nSequence of the actor.\nUpsert an actor into the state tree\nSet the current base fee\nSet the circulating supply constant for the network\nSets the epoch to the specified value\nSet the current timestamp\nLink to the state of the actor.\nTake all the invocations that have been made since the …\nGet the current timestamp\nVerifies that two block headers provide proof of a …\nVerifies a window proof of spacetime.\nVerifies that a signature is valid for an address and …\nIdentifies the builtin actor types for usage with the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn expectation for a method invocation trace. Non-optional …\nA trace of an actor method invocation.\nerror_number is set when an unexpected syscall error occurs\nIf error_number is set, exit_code and return_value are not …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAsserts that a trace matches this expectation, including …\nArray type used within actors. The underlying type is an …\nDeal weight\nThe expected number of block producers in each epoch.\nMap type to be used within actors. The underlying type is …\nCreate a HAMT with a custom bit-width.\nCreate a map with a root Cid.\nCreate a map with a root Cid.\nThe error type returned by actor method calls.\nReturns the exit code of the error.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nError message of the actor error.\nCreates a new <code>ActorError</code>. This method does not check that …\nPrefix error message with a string message.\nThe expected number of block producers in each epoch.\nDefines first available ID address after builtin actors\nDefine Builtin Actor Addresses\nSpecifies a domain for randomness generation.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait to allow multiple error types to be able to be …\n<code>Multimap</code> stores multiple values per key in a HAMT of AMTs. …\nSet is a HAMT with empty values for the purpose of acting …\n<code>SetMultimap</code> is a HAMT with values that are also a HAMT but …\nAdds a value for a key.\nCollects all keys from the set into a vector.\nDeletes key from set.\nDowncast a dynamic std Error into an <code>ActorError</code>. If the …\nWrap the error with a message, without overwriting an exit …\nIterates through all arrays in the <code>Multimap</code>\nIterates through all values in the array at a given key.\nIterates through keys and converts them to a <code>DealID</code> to …\nIterates through all keys in the set.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes a <code>Multimap</code> from a root Cid\nInitializes a <code>SetMultimap</code> from a root Cid.\nInitializes a Set from a root Cid.\nGets the Array of value type <code>V</code> using the <code>Multimap</code> store.\nGets the set at the given index of the <code>SetMultimap</code>\nChecks if key exists in the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a new empty <code>Multimap</code>. The <code>outer_bitwidth</code> is …\nInitializes a new empty <code>SetMultimap</code>.\nInitializes a new empty Set with the default bit-width.\nInitializes a new empty Set given a bit-width.\nPuts the <code>DealID</code> in the hash set of the key.\nAdds key to the set.\nPuts slice of <code>DealID</code>s in the hash set of the key.\nRemoves a <code>DealID</code> from a key hash set.\nRemoves all values for a key.\nRemoves set at index.\nRetrieve root from the <code>Multimap</code>.\nRetrieve root from the <code>SetMultimap</code>.\nRetrieve root from the Set.\nArray type used within actors. The underlying type is an …\nDeal weight\nThe expected number of block producers in each epoch.\nMap type to be used within actors. The underlying type is …\nCreate a HAMT with a custom bit-width.\nCreate a map with a root Cid.\nCreate a map with a root Cid.\nThe error type returned by actor method calls.\nReturns the exit code of the error.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nError message of the actor error.\nCreates a new <code>ActorError</code>. This method does not check that …\nPrefix error message with a string message.\nThe expected number of block producers in each epoch.\nTypes of built-in actors that can be treated as principles.\nDefines first available ID address after builtin actors\nSpecifies a domain for randomness generation.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIdentifies the builtin actor types for usage with the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe maximum number of partitions that may be required to …\nThe maximum number of sector infos that may be required to …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nRatio of sector size to maximum deals per sector. The …\nThe number of blocks between payouts for deals\nMaximum number of unique “declarations” in batch …\nThe delay between pre-commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe default duration after a verified deal’s nominal …\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum number of control addresses a miner may register.\n<code>MaxMultiaddrData</code> is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\n<code>MaxPeerIDLength</code> is the maximum length allowed for any …\nMaximum total replica update proof size.\nMaximum number of epochs past the current epoch a sector …\nMaximum time a verified allocation can be active without …\nMaximum term for a verified data allocation (epochs)\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nMinimum miner consensus power\nMinimum verified deal size\nMinimum term for a verified data allocation (epochs)\nThe maximum number of new sectors that may be staged by a …\nNumber of epochs between publishing the pre-commit and …\nThe maximum number of sector pre-commitments in a single …\nDenominator of the percentage of normalized circulating …\nNumerator of the percentage of normalized circulating …\nThe maximum number of sector replica updates in a single …\nThe maximum number of sectors that a miner can have …\nAllowed post proof types for new miners\nAllowed pre-commit proof types for new miners\nStaging period for a miner worker key change. Finality is …\nLook-back from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\n<code>WPoStDisputeWindow</code> is the period after a challenge window …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nThe maximum number of partitions that may be required to …\nThe maximum number of sector infos that may be required to …\nEpochs after which chain state is final with overwhelming …\nNumber of epochs after a consensus fault for which a miner …\nRatio of sector size to maximum deals per sector. The …\n<code>DealUpdatesInterval</code> is the number of blocks between …\nMaximum number of unique “declarations” in batch …\nThe delay between pre-commit expiration and clean up from …\nMinimum period before a deadline’s challenge window …\nThe maximum age of a fault before the sector is terminated.\nMaximum total aggregated proof size.\nMaximum amount of sectors that can be aggregated.\nMaximum number of control addresses a miner may register.\n<code>MaxMultiaddrData</code> is the maximum amount of data that can be …\nMaximum number of partitions that will be assigned to a …\n<code>MaxPeerIDLength</code> is the maximum length allowed for any …\nMaximum total aggregated proof size.\nMaximum number of epochs past the current epoch a sector …\nMinimum amount of sectors that can be aggregated.\nMinimum number of epochs past the current epoch a sector …\nThe maximum number of new sectors that may be staged by a …\nNumber of epochs between publishing the pre-commit and …\nThe maximum number of sector pre-commitments in a single …\nThe maximum number of sector replica updates in a single …\nDenominator of the percentage of normalized circulating …\nNumerator of the percentage of normalized circulating …\nThe maximum number of sectors that a miner can have …\nStaging period for a miner worker key change. Finality is …\nLookback from the deadline’s challenge window opening …\nThe duration of a deadline’s challenge window, the …\nThe maximum distance back that a valid Window PoSt must …\nThe number of non-overlapping PoSt deadlines in each …\nThe period over which all a miner’s active sectors will …\nTrait to allow multiple error types to be able to be …\n<code>Multimap</code> stores multiple values per key in a HAMT of <code>Amt</code>s. …\nSet is a HAMT with empty values for the purpose of acting …\n<code>SetMultimap</code> is a HAMT with values that are also a HAMT but …\nAdds a value for a key.\nCollects all keys from the set into a vector.\nDeletes key from set.\nDowncast a dynamic std Error into an <code>ActorError</code>. If the …\nWrap the error with a message, without overwriting an exit …\nIterates through all arrays in the multi-map\nIterates through all values in the array at a given key.\nIterates through keys and converts them to a <code>DealID</code> to …\nIterates through all keys in the set.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes a <code>Multimap</code> from a root Cid\nInitializes a <code>SetMultimap</code> from a root Cid.\nInitializes a Set from a root Cid.\nGets the Array of value type <code>V</code> using the <code>Multimap</code> store.\nGets the set at the given index of the <code>SetMultimap</code>\nChecks if key exists in the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a new empty <code>Multimap</code>. The <code>outer_bitwidth</code> is …\nInitializes a new empty <code>SetMultimap</code>.\nInitializes a new empty Set with the default bit-width.\nInitializes a new empty Set given a bit-width.\nPuts the <code>DealID</code> in the hash set of the key.\nAdds key to the set.\nPuts slice of <code>DealID</code>s in the hash set of the key.\nRemoves a key from the <code>MapMap</code>, returning the value at the …\nRemoves a <code>DealID</code> from a key hash set.\nRemoves all values for a key.\nRemoves set at index.\nRetrieve root from the <code>Multimap</code>.\nRetrieve root from the <code>SetMultimap</code>.\nRetrieve root from the Set.")