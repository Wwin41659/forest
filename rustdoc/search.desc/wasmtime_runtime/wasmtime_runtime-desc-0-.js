searchState.loadedDescShard("wasmtime_runtime", 0, "Runtime library support for Wasmtime.\nOpaque state used to persist the state of the …\nA WebAssembly stack trace.\nTemporary state stored on the stack which is registered in …\nA unique identifier (within an engine or similar) for a …\nAn allocator for compiled module IDs.\nA WebAssembly Coredump\nA default memory allocator used by Wasmtime\nA “dynamic” table where table storage space is …\nThe value of an export passed from one instance to another.\nA function export value.\nA global export value.\nA memory export value.\nA table export value.\nAn <code>exrernref</code>.\nA stack frame within a Wasm stack trace.\nA <code>funcref</code>.\nA function export value.\nA global export value.\nResolved import pointers.\nA type that roughly corresponds to a WebAssembly instance, …\nRepresents a request for a new runtime instance.\nA thing that can allocate instances.\nTrait that represents the hooks needed to implement an …\nA handle holding an <code>Instance</code> of a WebAssembly module.\nInstance-related limit configuration for pooling.\nA trap raised from Cranelift-generated code.\nRepresentation of a runtime wasm linear memory.\nA memory export value.\nThe index of a memory allocation within an …\nOne backing image for one memory.\nSlot management of a copy-on-write image which can be …\nIndicates that <code>wait</code> did not complete and instead returned …\nA simple struct consisting of a page-aligned pointer to …\nA type akin to <code>Vec&lt;u8&gt;</code>, but backed by <code>mmap</code> and able to be …\nUsed by the runtime to query module information.\nUsed by the runtime to lookup information about a module …\nBacking images for memories in a module.\nFunctionality required by this crate for a particular …\nIndicates that a <code>wait</code> completed by being awoken by a …\nRepresents the on-demand instance allocator.\nImplements the pooling instance allocator.\nConfiguration options for the pooling instance allocator …\nOpaque state used to help control TLS state across stack …\nA linear memory\nA memory allocator\nA helper type in Wasmtime to store a raw pointer to <code>T</code> …\nFor shared memory (and only for shared memory), this …\nFunction which may handle custom signals while processing …\nA “static” table where storage space is managed …\nDynamic runtime functionality needed by this crate …\nA <code>Box&lt;T&gt;</code> lookalike for memory that’s stored in a <code>Store&lt;T&gt;</code>\nA pointer to a Store. This Option&lt;*mut dyn Store&gt; is …\nRepresents an instance’s table.\nA table export value.\nThe index of a table allocation within an <code>InstanceAllocator</code>…\nAn element going into or coming out of a table.\nIndicates that <code>wait</code> completed with a timeout, meaning that …\nStores trace message with backtrace.\nEnumeration of different methods of raising a trap.\nAn uninitialized funcref value. This should never be …\nRepresents a registration of function unwind information …\nA user-raised trap through <code>raise_user_trap</code>.\nx86 vectors are represented with XMM registers which are …\nVersion number of this crate.\nA function pointer that exposes the array calling …\nThe <code>VM*Context</code> for array-call host functions.\nThe VM “context”, which is pointed to by the <code>vmctx</code> arg …\nThe VM caller-checked “funcref” record, for …\nA placeholder byte-sized type which is just used to …\nAn imported function.\nThe storage for a WebAssembly global defined within the …\nThe fields compiled code needs to access to utilize a …\nThe storage for a WebAssembly invocation argument\nThe fields compiled code needs to access to utilize a …\nThe fields compiled code needs to access to utilize a …\nA function pointer that exposes the native calling …\nThe <code>VM*Context</code> for native-call host functions.\nAn “opaque” version of <code>VMContext</code> which must be …\nStructure used to control interrupting wasm code.\nAn index into the shared type registry, usable for …\nThe fields compiled code needs to access to utilize a …\nThe fields compiled code needs to access to utilize a …\nA function pointer that exposes the Wasm calling …\nA “raw” and unsafe representation of a WebAssembly …\nResult of <code>Memory::atomic_wait32</code> and <code>Memory::atomic_wait64</code>\nA trap raised from a wasm libcall\nDescription about a fault that occurred in WebAssembly.\nThere’s some more discussion about this within …\nCreate a new <code>Mmap</code> pointing to <code>accessible_size</code> bytes of …\nGet all globals within this instance.\nGet all globals within this instance.\nGet all memories within this instance.\nAllocate a new ID.\nAllocate the memories for the given instance allocation …\nAllocate the memories for the given instance allocation …\nAllocate a memory for an instance.\nAllocates a fresh <code>InstanceHandle</code> for the <code>req</code> given.\nAllocates a fresh <code>InstanceHandle</code> for the <code>req</code> given.\nAllocate a table for an instance.\nAllocate tables for the given instance allocation request, …\nAllocate tables for the given instance allocation request, …\nAllow access to memory regions protected by any protection …\nFunction pointer to use when calling this imported …\nFunction pointer for this funcref if being called via the …\nReturns the address, in memory, of the trampoline that …\nUsed for optional dynamic downcasting.\nReturn a reference to the value as an externref.\nReturn a mutable reference to the value as an externref.\nReturn a reference to the value as an f32.\nReturn a reference to the value as f32 bits.\nReturn a mutable reference to the value as f32 bits.\nReturn a mutable reference to the value as an f32.\nReturn a reference to the value as an f64.\nReturn a reference to the value as f64 bits.\nReturn a mutable reference to the value as f64 bits.\nReturn a mutable reference to the value as an f64.\nReturn a reference to the value as a <code>VMFuncRef</code>.\nReturn a mutable reference to the value as a <code>VMFuncRef</code>.\nReturn a reference to the value as an i32.\nReturn a mutable reference to the value as an i32.\nReturn a reference to the value as an i64.\nReturn a mutable reference to the value as an i64.\nConvert this shared memory into a <code>Memory</code>.\nUnsafely assert that this is a pointer to valid contents …\nReturn the allocated memory as a mutable pointer to u8.\nReturns the underlying <code>NonNull&lt;T&gt;</code> wrapper.\nReturns the underlying raw pointer.\nReturn the allocated memory as a pointer to u8.\nThe raw contents of this struct\nUnsafely assert that this is a pointer to valid contents …\nIf the Memory is a SharedMemory, unwrap it and return a …\nReturn a reference to the value as an u128.\nReturn a reference to the value as u128 bits.\nReturn a mutable reference to the value as u128 bits.\nReturn a mutable reference to the value as an u128.\nReturn a reference to the value as a u32.\nReturn a mutable reference to the value as an u32.\nReturn a reference to the value as an u64.\nReturn a mutable reference to the value as an u64.\nAsserts that the current CallThreadState pointer, if …\nPerforms a runtime check that this state is indeed null.\nThis method is only available when the <code>gc</code> cargo feature is …\nIf async stack zeroing is enabled and the host platform is …\nWhether or not async stacks are zeroed after use.\nImplementation of <code>memory.atomic.notify</code> for all memories.\nImplementation of <code>memory.atomic.notify</code> for this shared …\nImplementation of <code>memory.atomic.wait32</code> for all memories.\nImplementation of <code>memory.atomic.wait32</code> for this shared …\nImplementation of <code>memory.atomic.wait64</code> for all memories.\nImplementation of <code>memory.atomic.wait64</code> for this shared …\nWasm backtrace of the trap, if any.\nThe start address.\nPointer to the table data.\nReturns the underlying bits of the index.\nThe backtrace containing the stack frames for the CoreDump\nReturns the number of allocated bytes.\nReturns the number of allocated wasm pages.\nCatches any wasm traps that happen within the execution of …\nReturns a clone of this instance.\nThe maximum size of a component’s <code>VMComponentContext</code>, …\nCopy <code>len</code> elements from <code>src_table[src_index..]</code> into …\nMaximum size of a core instance’s <code>VMContext</code>.\nThe Wasm Coredump, if any.\nThe current number of elements in the table.\nReturn the current length of the <code>VMMemoryDefinition</code> by …\nThe current logical size of this linear memory in bytes.\nDeallocate all the memories in the given primary map.\nDeallocate all the memories in the given primary map.\nDeallocate an instance’s previously allocated memory.\nDeallocates the provided instance.\nDeallocates the provided instance.\nDeallocate an instance’s previously allocated table.\nDeallocate all the tables in the given primary map.\nDeallocate all the tables in the given primary map.\nThe dual of <code>increment_component_instance_count</code>.\nThe dual of <code>increment_core_instance_count</code>.\nGet the globals defined in this instance (not imported).\nGet the globals defined in this instance (not imported).\nReturn the memories defined within this instance (not …\nReturn the memories defined in this instance (not …\nThe address of the table descriptor.\nThe address of the memory descriptor.\nThe address of the global storage.\nReturns the type of the elements in this table.\nA pointer to no Store.\nReturns an empty backtrace\nDeadline epoch for interruption: if epoch-based …\nReturns a pointer to the global epoch counter.\nReturn a pointer to the global epoch counter used by this …\nReturn an iterator over the exports of this instance.\nReturn an iterator over the exports of this instance.\nCreates a WebAssembly <code>externref</code> value\nReturns the externref management structures necessary for …\nReturn a pointer to the <code>VMExternRefActivationsTable</code>.\nCreates a WebAssembly <code>f32</code> value\nCreates a WebAssembly <code>f64</code> value\nFill <code>table[dst..dst + len]</code> with <code>val</code>.\nGet this frame’s frame pointer.\nIterate over the frames inside this backtrace.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA pointer to the imported table description.\nA pointer to the imported memory description.\nA pointer to the imported global variable description.\nCreates a new <code>MmapVec</code> which is the <code>path</code> specified mmap’d …\nCreates a new <code>Mmap</code> by opening the file located at <code>path</code> and …\nHelper function to cast between context types using a …\nHelper function to cast between context types using a …\nHelper function to cast between context types using a …\nCreates a new <code>MmapVec</code> from the contents of an existing …\nHelper function to clearly indicate that casts are desired.\nHelper function to clearly indicate that casts are desired.\nHelper function to clearly indicate that casts are desired.\nConverts the provided <code>*mut VMContext</code> to an <code>Instance</code> …\nIndicator of how much fuel has been consumed and is …\nGet this context’s <code>VMFuncRef</code>.\nGet this context’s <code>VMFuncRef</code>.\nThe <code>VMFuncRef</code> for this exported function.\nCreates a WebAssembly <code>funcref</code> value\nReturns the address, in memory, that the function <code>index</code> …\nResolved addresses for imported functions.\nReturns the underlying pointer to <code>T</code> which is owned by the …\nGet reference to the specified element.\nGet a locally-defined memory.\nGet a table defined locally within this module.\nGets the raw runtime table data structure owned by this …\nGet a table defined locally within this module, lazily …\nLookup an item with the given index.\nLookup a function by index.\nLookup a global by index.\nLookup a memory by index.\nLookup a table by index.\nGets the WebAssembly <code>externref</code> value\nGets the WebAssembly <code>f32</code> value\nGets the WebAssembly <code>f64</code> value\nGets the WebAssembly <code>funcref</code> value\nGets the WebAssembly <code>i32</code> value\nGets the WebAssembly <code>i64</code> value\nGet the MemoryImage for a given memory.\nGets the WebAssembly <code>i32</code> value\nGets the WebAssembly <code>i64</code> value\nGets the WebAssembly <code>v128</code> value\nThe global declaration, used for compatibilty checking.\nResolved addresses for imported globals.\nGrows a memory by <code>delta_pages</code>.\nGrows a memory by <code>delta_pages</code>.\nGrow memory by the specified amount of wasm pages.\nGrow table by the specified amount of elements.\nSame as <code>RuntimeLinearMemory::grow</code>, except with <code>&amp;self</code>.\nGrow memory to the specified amount of bytes.\nReturn a reference to the custom state attached to this …\nReturn a reference to the custom state attached to this …\nGet the host state for this host function context.\nGet the host state for this host function context.\nThe host state to associate with the instance.\nCreates a WebAssembly <code>i32</code> value\nCreates a WebAssembly <code>i64</code> value\nReturns the bounds, in host memory, of where this mmap …\nThe imports to use for the instantiation.\nIncrement the count of concurrent component instances that …\nIncrement the count of concurrent core module instances …\nGet the underlying index of this <code>MemoryAllocationIndex</code>.\nGet the underlying index of this <code>TableAllocationIndex</code>.\nThe index at which the memory is defined within the <code>vmctx</code>.\nThe index of the memory in the containing <code>vmctx</code>.\nFill <code>table[dst..]</code> with values from <code>items</code>\nInitializes the contents of this table to the specified …\nThis function is required to be called before any …\nPerforms post-initialization of an instance after its …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn whether any memory has been allocated or reserved.\nIs this a JIT trap?\nThe last host stack pointer before we called into Wasm …\nThe value of the frame pointer register when we last …\nThe last Wasm program counter before we called from Wasm …\nReturns the slice’s length component of the pointer.\nReturn the length of the allocated memory.\nRuntime library calls.\nThe limits to apply to instances allocated within this …\nHow much linear memory, in bytes, to keep resident after …\nReturn a copy of the <code>VMMemoryDefinition</code> using the relaxed …\nUnimplemented The indices of the locals and operand_stack …\nLookup the module information from a program counter value.\nLookup the stack map at a program counter value.\nMake the memory starting at <code>start</code> and extending for <code>len</code> …\nMakes the specified <code>range</code> within this <code>mmap</code> to be …\nMakes the specified <code>range</code> within this <code>Mmap</code> to be …\nMakes the specified <code>range</code> within this <code>mmap</code> to be read-only.\nMakes the specified <code>range</code> within this <code>Mmap</code> to be readonly.\nThe maximum number of core module instances that a single …\nThe maximum number of Wasm linear memories that a …\nMaximum number of linear memories per instance.\nHow many memory protection keys to allocate.\nThe maximum number of tables that a component may …\nMaximum number of tables per instance.\nSee <code>PoolingAllocatorConfig::max_unused_warm_slots</code> in …\nReturns the maximum number of elements at runtime.\nReturns the maximum number of bytes the memory can grow to.\nReturns the maximum number of pages the memory can grow to …\nResolved addresses for imported memories.\nThe memory declaration, used for compatibility checking.\nCallback invoked to notify the store’s resource limiter …\nCallback invoked to allow the store’s resource limiter …\nReturns the <code>MemoryImage</code> structure used for copy-on-write …\nMaximum number of Wasm pages for each linear memory.\nWhether to enable memory protection keys.\nThe size of memory, in bytes, at the time of the fault.\nThe underlying Module.\nReturn a reference to a module.\nMemory Protection Keys (MPK) implementation for use in …\nFunction pointer to use when calling this imported …\nFunction pointer for this funcref if being called via the …\nReturns the address, in memory, of the trampoline that …\nDoes this memory need initialization? It may not if it …\nA pointer to a Store.\nConsumes an existing <code>mmap</code> and wraps it up into an <code>MmapVec</code>.\nCreates a new pointer wrapping the non-nullable pointer …\nAllocates space on the heap to store <code>val</code> and returns a …\nCreates new state that initially starts as null.\nCreate the context for the given host function.\nCreate the context for the given host function.\nCreate a compiled-module ID allocator.\nCreate a new <code>ModuleMemoryImages</code> for the given module. This …\nCreates a new on-demand instance allocator.\nCreates a new pooling instance allocator with the given …\nConstruct a new <code>SharedMemory</code>.\nRegisters precompiled unwinding information with the …\nCapture the current Wasm stack in a backtrace.\nCapture a core dump of the current wasm state\nConstruct a <code>VMGlobalDefinition</code>.\nCreate a new <code>VMSharedTypeIndex</code>.\nCreate a new invocation argument filled with zeroes\nCreate a new dynamic (movable) memory instance for the …\nCreate a new dynamic (movable) table instance for the …\nCallback invoked whenever an instance observes a new epoch …\nCreate new RuntimeLinearMemory\nCreate new MmapMemory\nCreate a new static (immovable) memory instance for the …\nCreate a new static (immovable) table instance for the …\nUse the next available protection key.\nCreates an “empty” instance handle which internally …\nOffset information for the current host.\nGet the saved SP upon entry into Wasm for the previous …\nGet the saved FP upon exit from Wasm for the previous …\nGet the saved PC upon exit from Wasm for the previous …\nUnimplemented The operands for each stack frame\nReturns the underlying file that this mmap is mapping, if …\nReturns the underlying file that this mmap is mapping, if …\nReturns the offset within the original mmap that this …\nCallback invoked whenever fuel runs out by a wasm …\nReturns the host OS page size, in bytes.\nGet this frame’s program counter.\nRequest that the instance’s memories be protected by a …\nGet the previous <code>CallThreadState</code>.\nPurges all lingering resources related to <code>module</code> from …\nPushes the saved state of this wasm’s call onto the …\nRaises a trap from inside library code immediately.\nRaises a trap immediately.\nRaises a user-defined trap immediately.\nOriginal reason from where this trap originated.\nPops a fiber’s linked list of activations and stores …\nRestrict access to memory regions protected by <code>pkey</code>.\nCarries a Rust panic across wasm code and resumes the …\nThe info related to the compiled version of this module, …\nReturn a pointer to the interrupts structure\nSet reference to the specified element.\nConfigure the <code>*mut dyn Store</code> internal pointer …\nReturns the number of allocated elements.\nReturn the allocated memory as a slice of u8.\nReturn the allocated memory as a mutable slice of u8.\nSplits the collection into two at the given index.\nCurrent stack limit of the wasm module.\nThe size, in bytes, of async stacks to allocate (not …\nGets a pointer to this instance’s <code>Store</code> which was …\nReturns the <code>Store</code> pointer that was stored on creation\nA pointer to the “store” for this instance to be …\nThe table declaration, used for compatibilty checking.\nMaximum number of table elements per table.\nCallback invoked to notify the store’s resource limiter …\nCallback invoked to allow the store’s resource limiter …\nReturn the table index for the given <code>VMTableDefinition</code>.\nSame as <code>linear_memory_keep_resident</code> but for tables.\nResolved addresses for imported tables.\nEagerly initialize thread-local runtime functionality. …\nThe maximum number of component instances that may be …\nThe maximum number of core module instances that may be …\nThe total number of linear memories in the pool, across …\nThe total number of tables in the pool, across all …\nWalk the current Wasm stack, calling <code>f</code> for each frame we …\nReturn the memory type for this <code>SharedMemory</code>.\nReturns an array, indexed by <code>SignatureIndex</code> of all …\nFunction signature’s type id.\nCreates a WebAssembly <code>i32</code> value\nCreates a WebAssembly <code>i64</code> value\nA unique ID for this particular module. This can be used to\nConsume the memory, returning its <code>MemoryImageSlot</code> if any …\nCreate a new <code>TrapReason::User</code> that already has a backtrace.\nCreate a new <code>TrapReason::User</code> that does not have a …\nCreates a WebAssembly <code>v128</code> value\nValidate whether a core module is allocatable with this …\nValidate whether a core module is allocatable with this …\nValidate whether a module is allocatable by this instance …\nReturn a reference to the vmctx used by compiled wasm code.\nReturn a raw pointer to the vmctx used by compiled wasm …\nPointer to the containing <code>VMContext</code>.\nPointer to the containing <code>VMContext</code>.\nThe VM state associated with this function.\nA pointer to the <code>VMContext</code> that owns the table description.\nA pointer to the <code>VMContext</code> that owns the memory …\nThe VM state associated with this function.\nReturn a <code>VMMemoryDefinition</code> for exposing the memory to …\nReturn a <code>VMMemoryDefinition</code> for exposing the memory to …\nReturn a pointer to the shared memory’s …\nReturns the raw pointer in memory where this store’s …\nReturn a <code>VMTableDefinition</code> for exposing the table to …\nReturns the range of addresses that may be reached by …\nReturns the range of bytes that WebAssembly should be able …\nThe WebAssembly address at which the fault occurred.\nFunction pointer to use when calling this imported …\nFunction pointer for this funcref if being called via the …\nA slice pointing to all data that is referenced by this …\nAttempts to convert from the host <code>addr</code> specified to a …\nReturn the address, in memory, of the trampoline that …\nCreate a new <code>Mmap</code> pointing to at least <code>size</code> bytes of …\nCreates a new zero-initialized <code>MmapVec</code> with the given <code>size</code>.\nIndicates ‘–wmemcheck’ flag.\nWrap an existing Memory with the locking provided by a …\nWhere data for this table is stored. The length of this …\nDynamically managed storage space for this table. The …\nMaximum size that <code>elements</code> can grow to.\nThe current size of the table.\nThe type of this table.\nThe type of this table.\nThe actual user trap error.\nIf the trap was a memory-related trap such as SIGSEGV then …\nWhether we need to capture a backtrace for this error or …\nThe program counter where this trap originated.\nThis module contains functions which are used for …\nActually public trampolines which are used by the runtime …\nUse MPK if supported by the current system; fall back to …\nDo not use MPK.\nUse MPK or fail if not supported.\nDescribe the tri-state configuration of memory protection …\nAn MPK protection key.\nA bit field indicating which protection keys should be …\nAllow access from all protection keys.\nOnly allow access to pages marked by the keys set in <code>mask</code>.\nConvert the <code>ProtectionKey</code> to its 0-based index; this is …\nRetrieve the current protection mask.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the MPK feature is supported.\nAllocate up to <code>max</code> protection keys.\nInclude <code>pkey</code> as another allowed protection key in the mask.\nMark a page as protected by this <code>ProtectionKey</code>.\nOnly allow access to memory protected with protection key …")