searchState.loadedDescShard("bellpepper", 0, "Self-contained sub-circuit implementations for various …\nThis basically is just an extension to <code>Option</code> which allows …\nThe BLAKE2s hash function with personalization support.\nGadgets for allocating bits in the circuit and performing …\nWindow table lookup gadgets.\nHelpers for packing vectors of bits into scalar field …\nGadgets representing numbers in the scalar field of the …\nCircuits for the SHA-256 hash function and its internal …\nCircuit representation of a <code>u32</code>, with helpers for the […\nRepresents a variable in the constraint system which is …\nThis is a boolean value which may be either a constant or …\nConstant (not an allocated variable)\nExistential view of the boolean variable\nNegated view of the boolean variable\nAllocate a variable in the constraint system which can …\nAllocate a variable in the constraint system which can …\nPerforms an AND operation over the two operands, returning …\nPerform AND over two boolean operands\nCalculates <code>a AND (NOT b)</code>.\nConstruct a boolean from a known constant\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalculates <code>(NOT a) AND (NOT b)</code>.\nReturn a negated interpretation of this boolean.\nComputes (a and b) xor ((not a) and c)\nComputes (a and b) xor (a and c) xor (b and c)\nPerforms an XOR operation over the two operands, returning …\nPerform XOR over two boolean operands\nPerforms a 3-bit window table lookup. <code>bits</code> is in …\nPerforms a 3-bit window table lookup, where one of the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTakes a sequence of booleans and exposes them as a single …\nTakes a sequence of booleans and exposes them as compact …\nAllocate a <code>Variable(Aux)</code> in a <code>ConstraintSystem</code>.\nAllocate a <code>Variable(Input)</code> in a <code>ConstraintSystem</code>.\nAllocate a <code>Variable</code> of either <code>Aux</code> or <code>Input</code> in a …\nTakes two allocated numbers (a, b) and returns (b, a) if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the allocated number into its little-endian …\nDeconstructs this allocated number into its boolean …\nRepresents an interpretation of 32 <code>Boolean</code> objects as an …\nPerform modular addition of several <code>UInt32</code> objects.\nAllocate a <code>UInt32</code> in the constraint system\nConstruct a constant <code>UInt32</code> from a <code>u32</code>\nReturns the argument unchanged.\nConverts a little-endian byte order representation of bits …\nCalls <code>U::from(self)</code>.\nTurns this <code>UInt32</code> into its little-endian byte order …\nCompute the <code>ch</code> value <code>(a and b) xor ((not a) and c)</code> during …\nCompute the <code>maj</code> value (a and b) xor (a and c) xor (b and c)\nXOR this <code>UInt32</code> with another <code>UInt32</code>\nThe <code>Comparable</code> trait allows comparison of two constraint …\nSupport for efficiently generating R1CS witness using …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA <code>ConstraintSystem</code> which calculates witness values for a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")