searchState.loadedDescShard("bellpepper_core", 0, "<code>bellpepper</code> is a crate for building zk-SNARK circuits. It …\nDuring synthesis, we lacked knowledge of a variable …\nComputations are expressed in terms of arithmetic …\nRepresents a constraint system which can have new variables\nDuring synthesis, we divided by zero.\nRepresents the index of either an input variable or …\nDuring proof generation, we encountered an I/O error with …\nThis represents a linear combination of some variables, …\nDuring GPU multiexp/fft, some GPU related error happened\nDuring verification, our verifying key was malformed.\nThis is a “namespaced” constraint system which borrows …\nDuring synthesis, our polynomials ended up being too high …\nRepresents the type of the “root” of this constraint …\nThis is an error that could occur during circuit synthesis …\nDuring CRS generation, we observed an unconstrained …\nDuring proof generation, we encountered an identity in the …\nDuring synthesis, we constructed an unsatisfiable …\nRepresents a variable in our constraint system.\nAllocate a private variable in the constraint system. The …\nAllocate a public variable in the constraint system. The …\nAllocate empty space for the auxiliary inputs and the main …\nAllocate empty space for the auxiliary inputs and the main …\nAllocate empty space for the auxiliary inputs of the …\nAllocate empty space for the auxiliary inputs of the …\nAllocate empty space for the main inputs of the …\nAllocate empty space for the main inputs of the …\nReturns the constraint system’s aux witness as a slice …\nReturns the constraint system’s aux witness as a slice …\nGadgets for allocating bits in the circuit and performing …\nEnforce that <code>A</code> * <code>B</code> = <code>C</code>. The <code>annotation</code> function is invoked …\nExtend concatenates thew  <code>other</code> constraint systems to the …\nExtend concatenates thew  <code>other</code> constraint systems to the …\nExtend the auxiliary inputs of the <code>ConstraintSystem</code>.\nExtend the auxiliary inputs of the <code>ConstraintSystem</code>.\nExtend the inputs of the <code>ConstraintSystem</code>.\nExtend the inputs of the <code>ConstraintSystem</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the “root” constraint system, bypassing the …\nThis returns the index underlying the variable. Circuit …\nReturns the constraint system’s inputs as a slice of …\nReturns the constraint system’s inputs as a slice of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMost implementations of ConstraintSystem are not ‘…\nMost implementations of ConstraintSystem are not ‘…\nDetermines if the current <code>ConstraintSystem</code> instance is a …\nDetermines if the current <code>ConstraintSystem</code> instance is a …\nBegin a namespace for this constraint system.\nBegin a namespace for this constraint system.\nThis constructs a variable with an arbitrary index. …\nGadgets representing numbers in the scalar field of the …\nThe <code>Comparable</code> trait allows comparison of two constraint …\nReturn the “one” input variable\nReturn the “one” input variable\nExit out of the existing namespace. Not intended for …\nCreate a new (sub)namespace and enter into it. Not intended\nSynthesize the circuit into a rank-1 quadratic constraint …\nRepresents a variable in the constraint system which is …\nThis is a boolean value which may be either a constant or …\nConstant (not an allocated variable)\nExistential view of the boolean variable\nNegated view of the boolean variable\nAllocate a variable in the constraint system which can …\nAllocate a variable in the constraint system which can …\nPerforms an AND operation over the two operands, returning …\nPerform AND over two boolean operands\nCalculates <code>a AND (NOT b)</code>.\nConstruct a boolean from a known constant\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalculates <code>(NOT a) AND (NOT b)</code>.\nReturn a negated interpretation of this boolean.\nComputes (a and b) xor ((not a) and c)\nComputes (a and b) xor (a and c) xor (b and c)\nPerforms an XOR operation over the two operands, returning …\nPerform XOR over two boolean operands\nAllocate a <code>Variable(Aux)</code> in a <code>ConstraintSystem</code>.\nAllocate a <code>Variable(Input)</code> in a <code>ConstraintSystem</code>.\nAllocate a <code>Variable</code> of either <code>Aux</code> or <code>Input</code> in a …\nTakes two allocated numbers (a, b) and returns (b, a) if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the allocated number into its little-endian …\nDeconstructs this allocated number into its boolean …\nConstraint system for testing purposes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")