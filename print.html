<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_usage.html"><strong aria-hidden="true">1.1.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">1.2.</strong> Command-line interface</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">1.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="docker.html"><strong aria-hidden="true">1.4.</strong> Docker</a></li><li class="chapter-item expanded "><a href="js_console.html"><strong aria-hidden="true">1.5.</strong> JavaScript Console</a></li><li class="chapter-item expanded "><a href="trouble_shooting.html"><strong aria-hidden="true">1.6.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">1.7.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Developer documentation</li><li class="chapter-item expanded "><a href="developer_documentation/introduction.html"><strong aria-hidden="true">2.</strong> Developer documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developer_documentation/contributing.html"><strong aria-hidden="true">2.1.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="developer_documentation/mainnet_compatibility.html"><strong aria-hidden="true">2.2.</strong> Mainnet compatibility</a></li><li class="chapter-item expanded "><a href="developer_documentation/memory-analysis.html"><strong aria-hidden="true">2.3.</strong> Memory analysis</a></li><li class="chapter-item expanded "><a href="developer_documentation/release_checklist.html"><strong aria-hidden="true">2.4.</strong> Release checklist</a></li><li class="chapter-item expanded "><a href="developer_documentation/smoke_testing.html"><strong aria-hidden="true">2.5.</strong> Smoke testing</a></li><li class="chapter-item expanded "><a href="developer_documentation/state_migration.html"><strong aria-hidden="true">2.6.</strong> State migration</a></li><li class="chapter-item expanded "><a href="developer_documentation/state_migration_guide.html"><strong aria-hidden="true">2.7.</strong> State migration guide</a></li><li class="chapter-item expanded "><a href="developer_documentation/state_migration_spike.html"><strong aria-hidden="true">2.8.</strong> State migration spike NV17-NV18</a></li><li class="chapter-item expanded "><a href="developer_documentation/test_plan.html"><strong aria-hidden="true">2.9.</strong> Test plan</a></li><li class="chapter-item expanded "><a href="developer_documentation/devnet_notes.html"><strong aria-hidden="true">2.10.</strong> Devnet Notes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
    <img width="380" height="269" src="./img/forest_logo.png">
</p>
<p><a href="https://app.circleci.com/pipelines/github/ChainSafe/forest?branch=main"><img alt="build status" src="https://img.shields.io/circleci/build/gh/ChainSafe/forest/main?style=for-the-badge" height="20"></a>
<a href="https://github.com/ChainSafe/forest/releases/latest"><img alt="GitHub release (latest by date)" src="https://img.shields.io/github/v/release/ChainSafe/forest?style=for-the-badge" height="20"></a>
<a href="https://opensource.org/licenses/Apache-2.0"><img alt="Apache License" src="https://img.shields.io/badge/License-Apache%202.0-blue.svg?style=for-the-badge" height="20"></a>
<a href="https://opensource.org/licenses/MIT"><img alt="MIT License" src="https://img.shields.io/badge/License-MIT-yellow.svg?style=for-the-badge" height="20"></a>
<a href="https://twitter.com/ChainSafeth"><img alt="Twitter" src="https://img.shields.io/twitter/follow/ChainSafeth.svg?style=for-the-badge&label=Twitter&color=1DA1F2" height="20"></a>
<a href="https://discord.gg/Q6A3YA2"><img alt="Discord" src="https://img.shields.io/discord/593655374469660673.svg?style=for-the-badge&label=Discord&logo=discord" height="20"></a></p>
<p>Forest is an implementation of <a href="https://filecoin.io/">Filecoin</a> written in Rust.
The implementation takes a modular approach to building a full Filecoin node in
two parts — (i) building Filecoin’s security critical systems in Rust from the
<a href="https://filecoin-project.github.io/specs/">Filecoin Protocol Specification</a>,
specifically the virtual machine, blockchain, and node system, and (ii)
integrating functional components for storage mining and storage &amp; retrieval
markets to compose a fully functional Filecoin node implementation.</p>
<h2 id="functionality"><a class="header" href="#functionality">Functionality</a></h2>
<ul>
<li>Filecoin State Tree Synchronization</li>
<li>Filecoin JSON-RPC Server</li>
<li>Ergonomic Message Pool</li>
<li>Wallet CLI</li>
<li>Process Metrics &amp; Monitoring</li>
</ul>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>The Forest implementation of the Filecoin protocol is alpha software which
should not yet be integrated into production workflows. The team is working to
provide reliable, secure, and efficient interfaces to the Filecoin ecosystem. If
you would like to chat, please reach out over Discord on the ChainSafe server
linked above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<ul>
<li>Rust <code>rustc &gt;= 1.58.1</code></li>
<li>Rust WASM target <code>wasm32-unknown-unknown</code></li>
</ul>
<pre><code class="language-shell">rustup install stable
rustup target add wasm32-unknown-unknown
</code></pre>
<ul>
<li>OS Base-Devel/Build-Essential</li>
<li>Clang compiler</li>
<li>OpenCL bindings</li>
</ul>
<pre><code class="language-shell"># Ubuntu
sudo apt install build-essential clang

# Archlinux
sudo pacman -S base-devel clang
</code></pre>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<pre><code class="language-bash">make release
</code></pre>
<h2 id="forest-import-snapshot-mode"><a class="header" href="#forest-import-snapshot-mode">Forest Import Snapshot Mode</a></h2>
<p>Before running <code>forest</code> in the normal mode you must seed the database with the
Filecoin state tree from the latest snapshot. To do that, we will download the
latest snapshot provided by Protocol Labs and start <code>forest</code> using the
<code>--import-snapshot</code> flag. After the snapshot has been successfully imported, you
can start <code>forest</code> without the <code>--import-snapshot</code> flag.</p>
<h3 id="commands-1"><a class="header" href="#commands-1">Commands</a></h3>
<p>Download the latest snapshot provided by Protocol Labs:</p>
<pre><code class="language-bash">curl -sI https://fil-chain-snapshots-fallback.s3.amazonaws.com/mainnet/minimal_finality_stateroots_latest.car | perl -ne '/x-amz-website-redirect-location:\s(.+)\.car/ &amp;&amp; print &quot;$1.sha256sum\n$1.car&quot;' | xargs wget
</code></pre>
<p>If desired, you can check the checksum using the instructions
<a href="https://lotus.filecoin.io/docs/set-up/chain-management/#lightweight-snapshot">here</a>.</p>
<p>Import the snapshot using <code>forest</code>:</p>
<pre><code class="language-bash">forest --target-peer-count 50 --encrypt-keystore false --import-snapshot /path/to/snapshot/file
</code></pre>
<h2 id="forest-synchronization-mode"><a class="header" href="#forest-synchronization-mode">Forest Synchronization Mode</a></h2>
<h3 id="commands-2"><a class="header" href="#commands-2">Commands</a></h3>
<h4 id="mainnet"><a class="header" href="#mainnet">Mainnet</a></h4>
<p>Start the <code>forest</code> node:</p>
<pre><code class="language-bash">forest --target-peer-count 50 --encrypt-keystore false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli"><a class="header" href="#cli">CLI</a></h1>
<p>The Forest CLI allows for operations to interact with a Filecoin node and the
blockchain.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>For nodes not running on a non-default port, or when interacting with a node
remotely, you will need to provide the multiaddress information for the node.
You will need to either set the environment variable <code>FULLNODE_API_INFO</code>, or
prepend it to the command, like so:</p>
<p><code>FULLNODE_API_INFO=&quot;...&quot; forest wallet new -s bls</code></p>
<p>On Linux, you can set the environment variable with the following syntax</p>
<p><code>export FULLNODE_API_INFO=&quot;...&quot;</code></p>
<p>Setting your API info this way will limit the value to your current session.
Look online for ways to persist this variable if desired.</p>
<p>The syntax for the <code>FULLNODE_API_INFO</code> variable is as follows:</p>
<p><code>&lt;admin_token&gt;:/ip4/&lt;ip of host&gt;/tcp/&lt;port&gt;/http</code></p>
<p>This will use IPv4, TCP, and HTTP when communicating with the RPC API. The admin
token can be found when starting the Forest daemon. This will be needed to
create tokens with certain permissions such as read, write, sign, or admin.</p>
<h2 id="token-flag"><a class="header" href="#token-flag">Token flag</a></h2>
<p>For nodes running on default port and when you are interacting locally, the
admin token can also be set using <code>--token</code> flag:</p>
<pre><code>forest-cli --token eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJBbGxvdyI6WyJyZWFkIiwid3JpdGUiLCJzaWduIiwiYWRtaW4iXSwiZXhwIjoxNjczMjEwMTkzfQ.xxhmqtG9O3XNTIrOEB2_TWnVkq0JkqzRdw63BdosV0c &lt;subcommand&gt;
</code></pre>
<h2 id="sending-filecoin-tokens-from-your-wallet"><a class="header" href="#sending-filecoin-tokens-from-your-wallet">Sending Filecoin tokens from your wallet</a></h2>
<p>For sending Filecoin tokens, the Forest daemon must be running. You can do so by
running:</p>
<p><code>forest --chain calibnet</code></p>
<p>Next, send Filecoin tokens to a wallet address:</p>
<p><code>forest-cli --token &lt;admin_token&gt; send &lt;wallet-address&gt; &lt;amount in attoFIL&gt;</code></p>
<p>where 1 attoFIL = $10^{−18}$ FIL.</p>
<h2 id="wallet"><a class="header" href="#wallet">Wallet</a></h2>
<p>Filecoin wallets are stored under the Forest data directory (e.g.,
<code>~/.local/share/forest</code> in the case of Linux) in a <code>keystore</code> file.</p>
<p>All wallet commands require write permissions and an admin token (<code>--token</code>) to
interact with the keystore. The admin token can be retrieved from forest startup
logs or by running it with <code>--save-token &lt;PATH&gt;</code>.</p>
<p>Balance Retrieve the FIL balance of a given address Usage:
<code>forest-cli wallet balance &lt;address&gt;</code></p>
<p>Default Get the default, persisted address from the keystore Usage:
<code>forest-cli wallet default</code></p>
<p>Has Check if an address exists in the keystore shows true/false if exists or
doesn't Usage: <code>forest-cli wallet has &lt;address&gt;</code></p>
<p>List Display the keys in the keystore Usage: <code>forest-cli wallet list</code></p>
<p>New Create a new wallet The signature type can either be secp256k1 or bls.
Defaults to use bls Usage: <code>forest-cli wallet new &lt;bls/secp256k1&gt;</code></p>
<p>Set-default Set an address to be the default address of the keystore Usage:
<code>forest-cli wallet set-default &lt;address&gt;</code></p>
<p>Import Import a private key to the keystore and create a new address. The
default format for importing keys is hex encoded JSON. Use the <code>export</code> command
to get formatted keys for importing. Usage:
<code>forest-cli wallet import &lt;hex encoded json key&gt;</code></p>
<p>Export Export a key by address. Use a wallet address to export a key. Returns a
formatted key to be used to import on another node, or into a new keystore.
Usage: forest-cli wallet export <address></p>
<p>Sign Use an address to sign a vector of bytes Usage:
<code>forest-cli wallet sign -m &lt;hex message&gt; -a &lt;address&gt;</code></p>
<p>Verify Verify the message's integrity with an address and signature Usage:
<code>forest-cli wallet verify -m &lt;hex message&gt; -a &lt;address&gt; -s &lt;signature&gt;</code></p>
<h2 id="chain-sync"><a class="header" href="#chain-sync">Chain-Sync</a></h2>
<p>The chain-sync CLI can mark blocks to never be synced, provide information about
the state of the syncing process, and check blocks that will never be synced
(and for what reason).</p>
<p>Wait Wait for the sync process to be complete Usage: <code>forest-cli sync wait</code>
Permissions: Read</p>
<p>Status Check the current state of the syncing process, displaying some
information Usage: <code>forest-cli sync status</code> Permissions: Read</p>
<p>Check Bad Check if a block has been marked by, identifying the block by CID
Usage: <code>forest-cli sync check-bad -c &lt;block cid&gt;</code> Permissions: Read</p>
<p>Mark Bad Mark a block as bad, the syncer will never sync this block Usage:
<code>forest-cli sync mark-bad -c &lt;block cid&gt;</code> Permissions: Admin</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>The <code>forest</code> process has a set of configurable values which determine the
behavior of the node. All values can be set through process flags or through a
configuration file. If a configuration is provided through the flag and the
configuration file, the flag value will be given preference.</p>
<h2 id="flags"><a class="header" href="#flags">Flags</a></h2>
<p>When starting <code>forest</code> you can configure the behavior of the process through the
use of the following flags:</p>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>--config</td><td>OS File Path</td><td>Path to TOML file containing configuration</td></tr>
<tr><td>--genesis</td><td>OS File Path</td><td>CAR file with genesis state</td></tr>
<tr><td>--rpc</td><td>Boolean</td><td>Toggles the RPC API on</td></tr>
<tr><td>--port</td><td>Integer</td><td>Port for JSON-RPC communication</td></tr>
<tr><td>--token</td><td>String</td><td>Client JWT token to use for JSON-RPC authentication</td></tr>
<tr><td>--metrics-port</td><td>Integer</td><td>Port used for metrics collection server</td></tr>
<tr><td>--kademlia</td><td>Boolean</td><td>Determines whether Kademilia is allowed</td></tr>
<tr><td>--mdns</td><td>Boolean</td><td>Determines whether MDNS is allowed</td></tr>
<tr><td>--import-snapshot</td><td>OS File Path</td><td>Path to snapshot CAR file</td></tr>
<tr><td>--import-chain</td><td>OS File Path</td><td>Path to chain CAR file</td></tr>
<tr><td>--skip-load</td><td>Boolean</td><td>Skips loading CAR File and uses header to index chain</td></tr>
<tr><td>--req-window</td><td>Integer</td><td>Sets the number of tipsets requested over chain exchange</td></tr>
<tr><td>--tipset-sample-size</td><td>Integer</td><td>Number of tipsets to include in the sample which determines the network head during synchronization</td></tr>
<tr><td>--target-peer-count</td><td>Integer</td><td>Amount of peers the node should maintain a connection with</td></tr>
<tr><td>--encrypt-keystore</td><td>Boolean</td><td>Controls whether the keystore is encrypted</td></tr>
</tbody></table>
</div>
<h2 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h2>
<p>Alternatively, when starting <code>forest</code> you can define a TOML configuration file
and provide it to the process with the <code>--config</code> flag or through the
<code>FOREST_CONFIG_PATH</code> environment variable.</p>
<p>The following is an sample configuration file:</p>
<pre><code class="language-toml">genesis = &quot;/path/to/genesis/file&quot;
rpc = true
port = 1234
token = &quot;0394j3094jg0394jg34g&quot;
metrics-port = 2345
kademlia = true
mdns = true
import-snapshot = /path/to/snapshot/file
import-chain = /path/to/chain/file
skip-load = false
req-window = 100
tipset-sample-size = 10
target-peer-count = 100
encrypt-keystore = false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forest-in-docker"><a class="header" href="#forest-in-docker">Forest in Docker🌲❤️🐋</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Docker engine installed and running. Forest containers are confirmed to run on
the following engines:
<ul>
<li>Docker Engine (Community) on Linux,</li>
<li>Docker for macOS</li>
<li>Podman on WSL</li>
</ul>
</li>
</ul>
<p>Native images are available for the following platforms:</p>
<ul>
<li><code>linux/arm64</code></li>
<li><code>linux/amd64</code></li>
</ul>
<p>The images will work out-of-the box on both Intel processors and macOS with
M1/M2.</p>
<h2 id="tags"><a class="header" href="#tags">Tags</a></h2>
<p>For the list of all available tags please refer to the
<a href="https://github.com/ChainSafe/forest/pkgs/container/forest">Forest packages</a>.</p>
<p>Currently, the following tags are produced:</p>
<ul>
<li><code>latest</code> - latest stable release,</li>
<li><code>edge</code> - latest development build of the <code>main</code> branch,</li>
<li><code>date-digest</code> e.g., <code>2023-02-17-5f27a62</code> - all builds that landed on the
<code>main</code> branch,</li>
<li>release tags, available from <code>v.0.7.0</code> onwards.</li>
</ul>
<h2 id="security-recommendations"><a class="header" href="#security-recommendations">Security recommendations</a></h2>
<ul>
<li>We strongly recommend running the docker daemon in rootless mode
(<a href="https://docs.docker.com/engine/security/rootless/">installation instructions</a>),
or running the daemon-less docker alternative <code>podman</code>
(<a href="https://podman.io/getting-started/installation">installation instructions</a>)
with non-root user and put <code>alias docker = podman</code> (or manually replace the
<code>docker</code> commands with <code>podman</code> in below instructions)</li>
</ul>
<h2 id="performance-recommendations"><a class="header" href="#performance-recommendations">Performance recommendations</a></h2>
<ul>
<li>We recommend lowering the swappiness kernel parameter on linux to 1-10 for
long running forest node by doing <code>sudo sysctl -w vm.swappiness=[n]</code>.</li>
</ul>
<p>References: <a href="https://en.wikipedia.org/wiki/Memory_paging#Swappiness">1</a>
<a href="https://linuxhint.com/understanding_vm_swappiness/">2</a></p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="list-available-flags-andor-commands"><a class="header" href="#list-available-flags-andor-commands">List available flags and/or commands</a></h3>
<pre><code class="language-shell"># daemon
❯ docker run --init -it --rm ghcr.io/chainsafe/forest:latest --help
# cli
❯ docker run --init -it --rm --entrypoint forest-cli ghcr.io/chainsafe/forest:latest --help
</code></pre>
<h3 id="create-a-forest-node-running-calibration-network-then-list-all-connected-peers"><a class="header" href="#create-a-forest-node-running-calibration-network-then-list-all-connected-peers">Create a Forest node running calibration network. Then list all connected peers.</a></h3>
<pre><code class="language-shell">❯ docker run --init -it --rm --name forest ghcr.io/chainsafe/forest:latest --chain calibnet --auto-download-snapshot
</code></pre>
<p>then in another terminal (sample output)</p>
<pre><code class="language-shell">❯ docker exec -it forest forest-cli net peers
12D3KooWAh4qiT3ZRZgctVJ8AWwRva9AncjMRVBSkFwNjTx3EpEr, [/ip4/10.0.2.215/tcp/1347, /ip4/52.12.185.166/tcp/1347]
12D3KooWMY4VdMsdbFwkHv9HxX2jZsUdCcWFX5F5VGzBPZkdxyVr, [/ip4/162.219.87.149/tcp/30141, /ip4/162.219.87.149/tcp/30141/p2p/12D3KooWMY4VdMsdbFwkHv9HxX2jZsUdCcWFX5F5VGzBPZkdxyVr]
12D3KooWFWUqE9jgXvcKHWieYs9nhyp6NF4ftwLGAHm4sCv73jjK, [/dns4/bootstrap-3.calibration.fildev.network/tcp/1347]
</code></pre>
<h3 id="use-a-shared-volume-to-utilise-across-different-forest-images"><a class="header" href="#use-a-shared-volume-to-utilise-across-different-forest-images">Use a shared volume to utilise across different Forest images</a></h3>
<p>Create the volume</p>
<pre><code class="language-shell">docker volume create forest-data
</code></pre>
<p>Now, whenever you create a new Forest container, attach the volume to where the
data is stored <code>/home/forest/.local/share/forest</code>.</p>
<pre><code class="language-shell">❯ docker run --init -it --rm \
             --ulimit nofile=8192 \
             --volume forest-data:/home/forest/.local/share/forest \
             --name forest ghcr.io/chainsafe/forest:latest --chain calibnet
                                                           --auto-download-snapshot
</code></pre>
<h3 id="export-the-calibnet-snapshot-to-the-host-machine"><a class="header" href="#export-the-calibnet-snapshot-to-the-host-machine">Export the calibnet snapshot to the host machine</a></h3>
<p>Assuming you have <code>forest</code> container already running, run:</p>
<pre><code class="language-shell">❯ docker exec -it forest forest-cli --chain calibnet snapshot export
Export completed. Snapshot located at forest_snapshot_calibnet_2023-02-17_height_308891.car
</code></pre>
<p>Copy the snapshot to the host</p>
<pre><code class="language-shell">❯ docker cp forest:/home/forest/forest_snapshot_calibnet_2023-02-17_height_308891.car .
</code></pre>
<h3 id="create-and-fund-a-wallet-then-send-some-fil-on-calibration-network"><a class="header" href="#create-and-fund-a-wallet-then-send-some-fil-on-calibration-network">Create and fund a wallet, then send some FIL on calibration network</a></h3>
<p>Assuming you have <code>forest</code> container already running, you need to find the JWT
token in the logs.</p>
<pre><code class="language-shell">❯ docker logs forest | grep &quot;Admin token&quot;
</code></pre>
<p>export it to an environmental variable for convenience (sample, use the token
you obtained in the previous step)</p>
<pre><code class="language-shell">export JWT_TOKEN=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJBbGxvdyI6WyJyZWFkIiwid3JpdGUiLCJzaWduIiwiYWRtaW4iXSwiZXhwIjoxNjgxODIxMTc4fQ.3toXEeiGcHT01pUjQeqMyW2kZmQpqpE4Gi4vOHjX4rE
</code></pre>
<p>Create the wallet</p>
<pre><code class="language-shell">❯ docker exec -it forest forest-cli --chain calibnet --token $JWT_TOKEN wallet new
f1uvqpa2jgic7fhhko3w4wf3kxj36qslvqrk2ln5i
</code></pre>
<p>Fund it using the
<a href="https://faucet.calibration.fildev.network/funds.html">faucet</a>. You can verify
it was funded after a few minutes in <a href="https://calibration.filscan.io/">Filscan</a>
by pasting the Message ID obtained from the faucet. Example from
<a href="https://calibration.filscan.io/tipset/message-detail?cid=bafy2bzacebdverplts5qs3lwzsenzlh4rdsmvc42r6yg6suu4comr7gkbe76a">this wallet</a>.
Please note the first letter of the address is<code>t</code> and not <code>f</code>. This is a known
issue.</p>
<p>Verify that your account has 100 FIL . The result is in <code>attoFIL</code>.</p>
<pre><code class="language-shell">❯ docker exec -it forest forest-cli --chain calibnet --token $JWT_TOKEN wallet balance t1uvqpa2jgic7fhhko3w4wf3kxj36qslvqrk2ln5i
100000000000000000000
</code></pre>
<p>Create another wallet</p>
<pre><code class="language-shell">❯ docker exec -it forest forest-cli --chain calibnet --token $JWT_TOKEN wallet new
f1wa7lgs7b3p5a26abkgpxwjpw67tx4fbsryg6tca
</code></pre>
<p>Send 10 FIL from the original wallet to the new one</p>
<pre><code class="language-shell">❯ docker exec -it forest forest-cli --chain calibnet --token $JWT_TOKEN send --from f1uvqpa2jgic7fhhko3w4wf3kxj36qslvqrk2ln5i f1wa7lgs7b3p5a26abkgpxwjpw67tx4fbsryg6tca 10000000000000000000
</code></pre>
<p>Verify the balance of the new address.
<a href="https://calibration.filscan.io/tipset/message-detail?cid=bafy2bzacebymw25tedmec4xnwmf7fcrt64qvfbbuacbx6lnhyrcbfv3rgkn2a">Sample transaction</a>
for this wallet.</p>
<pre><code class="language-shell">❯ docker exec -it forest forest-cli --chain calibnet --token $JWT_TOKEN wallet balance f1wa7lgs7b3p5a26abkgpxwjpw67tx4fbsryg6tca
10000000000000000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forest-javascript-console"><a class="header" href="#forest-javascript-console">Forest JavaScript Console</a></h1>
<p>Forest console stands as an alternative to tools like
<a href="https://github.com/curl/curl">Curl</a> or other subcommands found in <code>forest-cli</code>
for interacting with the Filecoin JSON-RPC API.</p>
<h2 id="starting-the-console"><a class="header" href="#starting-the-console">Starting the console</a></h2>
<p><code>forest-cli attach</code> can be used to open a Javascript console connected to your
Forest node.</p>
<p>Like for some other <code>forest-cli</code> subcommands you will need to pass an admin
<code>--token</code> given what endpoints you will call.</p>
<p>For a description of different options please refer to the developer
documentation
<a href="https://github.com/ChainSafe/forest/blob/main/documentation/developer_documentation/CLI.md#cli">CLI page</a>.</p>
<h2 id="interactive-use"><a class="header" href="#interactive-use">Interactive Use</a></h2>
<p>First start Forest node inside another terminal:</p>
<pre><code class="language-bash">forest --chain calibnet
</code></pre>
<p>To attach to your Forest node, run <code>forest-cli</code> with the <code>attach</code> subcommand:</p>
<pre><code class="language-bash">forest-cli --token &lt;TOKEN&gt; attach
</code></pre>
<p>You should now see a prompt and be able to interact:</p>
<pre><code>Welcome to the Forest Javascript console!

To exit, press ctrl-d or type :quit
&gt; console.log(&quot;Forest running on &quot; + chainGetName())
Forest running on calibnet
</code></pre>
<p>You can directly call JSON-RPC API endpoints that are bound to the console.</p>
<p>For example, <code>Filecoin.ChainGetName</code> is bound to the global <code>chainGetName</code>
function.</p>
<h3 id="tips"><a class="header" href="#tips">Tips</a></h3>
<ul>
<li>The console history is saved in your <code>~/.forest_history</code> after exiting.</li>
<li>Use <code>:clear</code> to erase <em>current</em> session commands.</li>
<li>Use <code>_BOA_VERSION</code> to get engine version</li>
</ul>
<h2 id="non-interactive-use"><a class="header" href="#non-interactive-use">Non-interactive Use</a></h2>
<h3 id="exec-mode"><a class="header" href="#exec-mode">Exec Mode</a></h3>
<p>It is also possible to execute commands non-interactively by passing <code>--exec</code>
flag and a JavaScript snippet to <code>forest-cli attach</code>. The result is displayed
directly in the terminal rather than in the interactive console.</p>
<p>For example, to display the current epoch:</p>
<pre><code class="language-bash">forest-cli attach --exec &quot;syncStatus().ActiveSyncs[0].Epoch&quot;
</code></pre>
<p>Or print wallet default address:</p>
<pre><code class="language-bash">forest-cli attach --exec &quot;console.log(walletDefaultAddress())&quot;
</code></pre>
<h2 id="builtins"><a class="header" href="#builtins">Builtins</a></h2>
<h3 id="helpers"><a class="header" href="#helpers">Helpers</a></h3>
<p>Forest console comes with a number of helper functions that make interacting
with Filecoin API easy:</p>
<ul>
<li><code>showPeers()</code></li>
<li><code>getPeer(peerID)</code></li>
<li><code>disconnectPeers(count)</code></li>
<li><code>isPeerConnected(peerID)</code></li>
<li><code>showWallet()</code></li>
<li><code>showSyncStatus()</code></li>
<li><code>sendFIL(to, amount)</code> (default amount unit is FIL)</li>
</ul>
<h3 id="timers"><a class="header" href="#timers">Timers</a></h3>
<p>In addition, to support part of the JavaScript language, the console also
provides implementation for <code>sleep(seconds)</code> timer and a tipset based timer,
<code>sleepTipsets(epochs)</code>, which sleeps till the number of new tipsets added is
equal to or greater than <code>epochs</code>.</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>CommonJS modules is the way to package JavaScript code for Forest console. You
can import modules using the <code>require</code> function:</p>
<pre><code class="language-bash">forest-cli attach --exec &quot;const Math = require('calc'); console.log(Math.add(39,3))&quot;
</code></pre>
<p>where <code>calc.js</code> is:</p>
<pre><code class="language-javascript">module.exports = {
  add: function (a, b) {
    return a + b;
  },
  multiply: function (a, b) {
    return a * b;
  },
};
</code></pre>
<p>By default modules will be loaded from the current directory. Use <code>--jspath</code>
flag to indicate another path.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Forest's console is built using
<a href="https://github.com/boa-dev/boa">Boa Javascript engine</a>. It does support
promises or <code>async</code> functions, but keep in mind that Boa is not fully compatible
with ECMAScript yet.</p>
<p>Not every endpoint from the Filecoin API has been bound to the console. Please
<a href="https://github.com/ChainSafe/forest/issues">create an issue</a> if you need one
that is not available.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trouble-shooting"><a class="header" href="#trouble-shooting">Trouble Shooting</a></h1>
<h2 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h2>
<h4 id="file-descriptor-limits"><a class="header" href="#file-descriptor-limits">File Descriptor Limits</a></h4>
<p>By default, Forest will use large database files (roughly 1GiB each). Lowering
the size of these files lets RocksDB use less memory but runs the risk of
hitting the open-files limit. If you do hit this limit, either increase the file
size or use <code>ulimit</code> to increase the open-files limit.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="algorand"><a class="header" href="#algorand">Algorand</a></h2>
<p><a href="https://www.algorand.com/">Algorand</a> is a proof-of-stake blockchain
cryptocurrency protocol.</p>
<h2 id="blake2b"><a class="header" href="#blake2b">BLAKE2b</a></h2>
<p>BLAKE2 is a cryptographic hash function based on
<a href="https://en.wikipedia.org/wiki/BLAKE_(hash_function)">BLAKE</a>. The design goal
was to replace the widely used, but broken, MD5 and SHA-1 algorithms in
applications requiring high performance in software.</p>
<h2 id="bls"><a class="header" href="#bls">BLS</a></h2>
<p><a href="https://en.wikipedia.org/wiki/BLS_digital_signature">BLS</a> stands for
Boneh–Lynn–Shacham cryptographic signature scheme, which is a cryptographic
signature scheme which allows a user to verify that a signer is authentic.</p>
<h2 id="cbor"><a class="header" href="#cbor">CBOR</a></h2>
<p><a href="https://cbor.io/">CBOR</a> stands for the Concise Binary Object Representation,
which is a data format whose design goals include the possibility of extremely
small code size, fairly small message size, and extensibility without the need
for version negotiation.</p>
<h2 id="cid"><a class="header" href="#cid">CID</a></h2>
<p><a href="https://spec.filecoin.io/#section-libraries.multiformats.cids">CID</a> is short
for Content Identifier, a self describing content address used throughout the
IPFS ecosystem. CIDs are used in Filecoin to identify files submitted to the
decentralized storage network. For more detailed information, see
<a href="https://github.com/ipld/cid">the github documentation for it</a>.</p>
<h2 id="ipld"><a class="header" href="#ipld">IPLD</a></h2>
<p><a href="https://github.com/ipld">IPLD</a> stands for InterPlanetary Linked Data, which is
a series of standards and formats for describing data in a
content-addressing-emphatic way.</p>
<h2 id="jwt"><a class="header" href="#jwt">JWT</a></h2>
<p><a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT</a> stands for JSON Web Token,
which is a proposed Internet standard for creating data with optional signature
and/or optional encryption whose payload holds JSON that asserts some number of
claims. The tokens are signed either using a private secret or a public/private
key.</p>
<h2 id="secp"><a class="header" href="#secp">SECP</a></h2>
<p>types of elliptic curves used for ECDSA see
<a href="https://www.johndcook.com/blog/2018/08/21/a-tale-of-two-elliptic-curves/">here</a></p>
<h2 id="multisig"><a class="header" href="#multisig">multisig</a></h2>
<p>A <a href="https://lotus.filecoin.io/lotus/manage/multisig/">multi-signature</a> (multisig)
wallet refers to a wallet that requires multiple keys to authorize a <code>FIL</code>
transactions.</p>
<h2 id="tipset"><a class="header" href="#tipset">Tipset</a></h2>
<p>Tipset is a structure that contains a non-empty collection of blocks that have
distinct miners and all specify identical epoch, parents, weight, height, state
root, receipt root</p>
<h2 id="tipsetkey"><a class="header" href="#tipsetkey">Tipsetkey</a></h2>
<p>A set of CIDs forming a unique key for a tipset.</p>
<h2 id="mempool"><a class="header" href="#mempool">mempool</a></h2>
<p>mempool stands for the Message Pool, which is the component of forest that
handles pending messages for inclusion in the chain. Messages are added either
directly for locally published messages or through pubsub propagation.</p>
<h2 id="merkle"><a class="header" href="#merkle">Merkle</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a> is a tree in which
every node is labelled with the cryptographic hash of a data block, and every
node that is not a leaf (called a branch, inner node, or inode) is labelled with
the cryptographic hash of the labels of its child nodes. A hash tree allows
efficient and secure verification of the contents of a large data structure.</p>
<h2 id="ipfs"><a class="header" href="#ipfs">IPFS</a></h2>
<p><a href="https://github.com/ipfs/ipfs">IPFS</a> stands for InterPlanetary File System which
is a peer-to-peer hypermedia protocol to make the web faster, safer, and more
open.</p>
<h2 id="proof-of-spacetime-post"><a class="header" href="#proof-of-spacetime-post">Proof of Spacetime (PoSt)</a></h2>
<p>PoSt stands for Proof-of-Spacetime is a procedure by which a storage-miner can
prove to the Filecoin network they have stored and continue to store a unique
copy of some data on behalf of the network for a period of time.</p>
<h2 id="hamt"><a class="header" href="#hamt">HAMT</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">HAMT</a> stands for Hash
array mapped trie, which is an implementation of an associative array that
combines the characteristics of a hash table and an array mapped trie.</p>
<h2 id="vrf"><a class="header" href="#vrf">VRF</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Verifiable_random_function">VRF</a> stands for a
Verifiable Random Function that receives a Secret Key (SK) and a seed and
outputs proof of correctness and output value. VRFs must yield a proof of
correctness and a unique &amp; efficiently verifiable output.</p>
<h2 id="mdns"><a class="header" href="#mdns">MDNS</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Multicast_DNS">MDNS</a> stands for Multicast DNS,
which is a protocol, that resolves hostnames to IP addresses within small
networks that do not include a local name server.</p>
<h2 id="kademlia"><a class="header" href="#kademlia">Kademlia</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Kademlia">Kademlia</a> is a distributed hash table
for decentralized peer-to-peer computer networks.</p>
<h2 id="libp2p"><a class="header" href="#libp2p">LibP2P</a></h2>
<p><a href="https://libp2p.io/">LibP2P</a> is a modular system of protocols, specifications
and libraries that enable the development of peer-to-peer network applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-documentation"><a class="header" href="#developer-documentation">Developer documentation</a></h1>
<p>In this section you will find resources targeted for Forest developers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribuiting-to-forest"><a class="header" href="#contribuiting-to-forest">Contribuiting to Forest</a></h1>
<h2 id="submitting-code"><a class="header" href="#submitting-code">Submitting Code</a></h2>
<p>Please use <code>make lint</code> to ensure code is properly formatted, license headers are
present, and to run the linter.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Please use the following guidelines while documenting code. Except for inline
comments, these should all be doc comments (<code>///</code>).</p>
<h3 id="methodsfunctions"><a class="header" href="#methodsfunctions">Methods/Functions</a></h3>
<ul>
<li>At least a brief description</li>
</ul>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<ul>
<li>At least a brief description</li>
</ul>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<ul>
<li>At least a brief description</li>
</ul>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<ul>
<li>At least a brief overall description.</li>
<li>All variants should have a brief description.</li>
</ul>
<h3 id="inline-comments"><a class="header" href="#inline-comments">Inline Comments</a></h3>
<ul>
<li>Any complicated logic should include in-line comments (<code>//</code>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-for-mainnet-compatibility"><a class="header" href="#testing-for-mainnet-compatibility">Testing for Mainnet Compatibility</a></h1>
<p>Forest development can be like hitting a moving target and sometimes Forest
falls behind the network. This document should serve as a way to easily identify
if Forest can sync all the way up to the network head using a simple
step-by-step process.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Some command-line tools and software is required to follow this guide.</p>
<ul>
<li>A fresh copy of the Forest repository that has been built</li>
<li>Lotus installed</li>
<li>curl (to download snapshots)</li>
<li>sha256sum (optional, used to verify snapshot integrity)</li>
</ul>
<h2 id="grab-a-snapshot-and-run-forest"><a class="header" href="#grab-a-snapshot-and-run-forest">Grab a snapshot and run Forest</a></h2>
<p>Refer to the mdbook documentation on how to download a snapshot and run forest</p>
<p>Warning: FileCoin snapshots as of this writing are over 75GB. Verify you have
enough space on your system to accommodate these large files.</p>
<ul>
<li>Use <code>make mdbook</code> in Forest's root directory</li>
<li>Open <code>http://localhost:3000</code></li>
<li>Navigate to <code>2. Basic Usage</code> in the menu on the right</li>
<li>Scroll down to <code>Forest Import Snapshot Mode</code></li>
</ul>
<h2 id="let-forest-sync"><a class="header" href="#let-forest-sync">Let Forest sync</a></h2>
<p>This step may take a while. We want Forest to get as far along in the syncing
process as it can get. If it syncs up all the way to the network head, CONGRATS!
Forest is up to date and on mainnet. Otherwise, Forest is not on mainnet.</p>
<p>If Forest starts to error and can't get past a block while syncing. Make note of
which block it is. We can use that block to help debug any potential state
mismatches.</p>
<h2 id="is-forest-on-the-latest-network-version"><a class="header" href="#is-forest-on-the-latest-network-version">Is Forest on the latest network version?</a></h2>
<p>Something easy to check is if Forest is on the latest Filecoin network version.
A repository exists where we can see all of the released network versions
<a href="https://github.com/filecoin-project/tpm/tree/master/Network%20Upgrades">here</a>.
Navigate the codebase to see mention of the latest network upgrade. If a
snapshot fails to sync at a certain epoch, it's entirely possible that the
snapshot was behind an epoch when a version upgrade started. Grab a new snapshot
by referring to the mdbook documentation.</p>
<h2 id="debugging-state-mismatches"><a class="header" href="#debugging-state-mismatches">Debugging State Mismatches</a></h2>
<p>Statediffs can only be printed if we import a snapshot containing the stateroot
data from Lotus. This means there will not be a pretty statediff if Forest is
already synced to the network when the stateroot mismatch happens. By default,
snapshots only contain stateroot data for the previous 2000 epochs. So, if you
have a statediff at epoch X, download a snapshot for epoch X+100 and tell Forest
to re-validate the snapshot from epoch X.</p>
<p>For more detailed instructions, follow
<a href="https://www.notion.so/chainsafe/Interop-debugging-6adabf9222d7449bbfeaacb1ec997cf8">this document</a></p>
<h2 id="fvm-traces"><a class="header" href="#fvm-traces">FVM Traces</a></h2>
<p>Within FVM, we can enable tracing to produce execution traces. Given an
offending epoch, we can produce them both for Forest and for Lotus to find
mismatches.</p>
<p>To confirm: the execution traces format is not uniform across implementations,
so it takes a certain amount of elbow grease to find the differences. Lotus is
capable of spitting this out in JSON for nice UX</p>
<div style="break-before: page; page-break-before: always;"></div><p>In case of memory leaks, either coming from <em>unsafe</em> libraries or just Forest
pushing shamelessly into some collection, it is useful to not guess where the
leak happened but to use proper tooling.</p>
<h1 id="heaptrack"><a class="header" href="#heaptrack"><a href="https://github.com/KDE/heaptrack">HeapTrack</a></a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Either build it with the instructions provided in the repository or download a
ready AppImage, e.g. from
<a href="https://invent.kde.org/sdk/heaptrack/-/releases">here</a>. You may not want to use
the <code>heaptrack</code> available in your OS packages as it may be a bit outdated.</p>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<p>To get the most out of the tool, you may want to add debug information to the
binary, regardless if you are running it in release or debug mode.</p>
<pre><code class="language-toml">[profile.dev]
debug = 2

[profile.release]
debug = 2
</code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>You can grab the trace on your host machine or in a VPS (e.g. Digital Ocean
Droplet).</p>
<p>Start tracing with <code>heaptrack &lt;normal forest command&gt;</code>, e.g.</p>
<pre><code>heaptrack target/release/forest --encrypt-keystore=false --target-peer-count 50 --chain calibnet --import-snapshot forest_snapshot.car
</code></pre>
<p>This will push traces to a file, e.g. <code>heaptrack.forest.12345.gz</code>. The longer
your process will be running, the bigger it will get, so double check your free
space before leaving it overnight.</p>
<p>Now analyze the trace. You can do it after Forest has e.g. crashed due to OOM or
even during its execution. If you were capturing traces in a Droplet, copy the
file to your host, e.g.
<code>scp chainsafe@123.45.66.77:/home/chainsafe/heaptrack.forest.12345.gz .</code>.</p>
<p>Depending on the size of the trace, it may take a while (but there is a nice
progress bar so you will know if you can grab a coffee in the meantime).</p>
<pre><code>heaptrack --analyze heaptrack.forest.12345.gz
</code></pre>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>Here we can see memory usage overview. Keep in mind that <em>leaks</em> here are not
necessarily leaks - it's just memory that hasn't been yet freed. A global cache
would always show as a leak.</p>
<p>While most of the potential <em>culprits</em> are not necessarily interesting (e.g.
<code>alloc::*</code>) because even a <code>String</code> constructor calls them, we immediately see
that among specific ones, it's the <code>rocksdb</code> that gets into the spotlight.</p>
<p><img src="developer_documentation/heaptrack/summary.png" alt="summary" /></p>
<h3 id="bottom-up"><a class="header" href="#bottom-up">Bottom-up</a></h3>
<p>View in which you see <em>low-level</em> methods first. In such view, the first methods
would almost always be allocator methods, finally unwinding into <code>main</code>.</p>
<p><img src="developer_documentation/heaptrack/bottom_up.png" alt="bottom-up" /></p>
<h3 id="callercallee"><a class="header" href="#callercallee">Caller/callee</a></h3>
<p>All the methods called along with their allocations, where one can easily
navigate between their callers and callees, also showing you the location in
code (you can configure <code>heaptrack</code> to take you to that code with
<code>Settings/Code Navigation</code>). Most useful tab when you delve into the details.</p>
<p><img src="developer_documentation/heaptrack/caller_callee.png" alt="caller-callee" /></p>
<h3 id="top-down"><a class="header" href="#top-down">Top-down</a></h3>
<p>Basically an inverse of <em>Bottom-up</em> view. High-level methods first, then you can
drill down.</p>
<h3 id="flamegraph"><a class="header" href="#flamegraph">Flamegraph</a></h3>
<p>A graphical form of Bottom-up and Top-Down (you can switch). Helps with
visualizing the heavy allocators.</p>
<p><img src="developer_documentation/heaptrack/flamegraph.png" alt="flamegraph-up" /></p>
<h3 id="consumed"><a class="header" href="#consumed">Consumed</a></h3>
<p>Shows the heap memory consumption over time. Here we can notice some patterns,
e.g. what happens with memory during snapshot import, then downloading headers
and syncing.</p>
<p><img src="developer_documentation/heaptrack/consumed.png" alt="consumed" /></p>
<h3 id="allocations"><a class="header" href="#allocations">Allocations</a></h3>
<p>Shows total number of allocations over time.</p>
<h3 id="temporary-allocations"><a class="header" href="#temporary-allocations">Temporary allocations</a></h3>
<p>Shows the number of temporary allocations over time. Temporary allocation is an
allocation followed by its deallocation, i.e. there are no other allocations
in-between.</p>
<h3 id="sizes"><a class="header" href="#sizes">Sizes</a></h3>
<p>This tab will show you the allocation sizes during runtime and their frequency.
If you hover over a bar you will see that e.g. <code>LZ4_createStream</code> (most likely
used by <code>rocksdb</code>) made 5,624,180 allocations, total 92.3G, on average 14.4kB
per allocation.</p>
<p><img src="developer_documentation/heaptrack/sizes.png" alt="sizes" /></p>
<h3 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h3>
<ul>
<li>Keep in mind that running Forest <em>with</em> heaptrack gives a non-negligible
memory and CPU overhead. You may not be able to run mainnet node on a 16G
machine even if normally it would be fine.</li>
<li>Optimizations may play tricks on the developer, e.g. inlining functions so
they won't even appear in your trace. If you think a particular method should
have been called but for mysterious reasons it does not appear in the
analysis, you may want to put <code>#[inline(never)]</code> on top of it. Analyzing a
debug build may also be useful, but depending on where the leak happens, it
may be too slow.</li>
<li>There is a lot of noise coming from dependencies and standard library. It's
useful to mentally filter them out a bit and focus on the biggest culprits in
Forest methods. Flamegraph and caller/callee view are the most useful for
this.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Forest follows a fixed, quarterly release schedule. On the last week of each
quarter, a new version is always released. This is supplemented with additional
releases for bug fixes and special features. A &quot;release officer&quot; is appointed
for each release and they are responsible for either following the checklist or,
in case of absence, passing the task to a different team member.</p>
<ol>
<li>Update the CHANGELOG.md file to reflect all changes and preferably write a
small summary about the most notable updates. The changelog should follow the
design philosophy outlined here: https://keepachangelog.com/en/1.0.0/. Go
through the output of <code>git log</code> and remember that the audience of the
CHANGELOG does not have intimate knowledge of the Forest code-base. All the
changed/updated/removed features should be reasonably understandable to an
end-user.</li>
<li>Update that version of the crates that are to be released. Forest contains
many crates so you may need to update many Cargo.toml files. If you're
working on a patch release, make sure that there are no breaking changes.
Cherry-picking of patches may be necessary.</li>
<li>Run the manual tests steps outlined in the TEST_PLAN.md. Caveat: Right now
there are no manual test steps so this step can be skipped.</li>
<li>Once the changes in step 1 and step 2 have been merged, tag the commit with
the new version number. The version tag should start with a lowercase 'v'.
Example: v0.4.1</li>
<li>(NOT YET APPLICABLE) Publish new crates on crates.io.</li>
<li>Go to https://github.com/ChainSafe/forest/releases/new and create a new
release. Use the tag created in step 4, follow the title convention of the
previous releases, and write a small summary of the release (similar or
identical to the summary in the CHANGELOG.md file).</li>
<li>Verify that the new release contains assets for both Linux and MacOS (the
assets are automatically generated and should show up after 30 minutes to an
hour).</li>
<li>Verify that the new release is available in the Github Container Registry.
Use <code>docker pull ghcr.io/chainsafe/forest:&lt;version&gt;</code> and ensure that it is
present in the <a href="https://github.com/ChainSafe/forest/pkgs/container/forest">packages</a></li>
<li>Update the <a href="https://github.com/ChainSafe/forest/wiki/Forest-Progress">Forest Progress</a> wiki with the changes in the new release. If
in doubt about what has been accomplished, is in progress, or what's included
in the future plans, ask in the #fil-devs slack channel and tag authors of
related PRs.</li>
<li>Make sure the <code>Cargo.lock</code> change is included in the pull request.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-smoke-tests-for-forests-rpc-api"><a class="header" href="#running-smoke-tests-for-forests-rpc-api">Running Smoke Tests for Forest's RPC API</a></h1>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>The only requirement for running these smoke tests is that Forest is installed
and on your system PATH.</p>
<h2 id="running-the-tests"><a class="header" href="#running-the-tests">Running the Tests</a></h2>
<ul>
<li>Use <code>make install</code> to create a binary on your path</li>
<li>Run <code>make smoke-test</code></li>
</ul>
<p>This will execute a blank request to all endpoints listed defined and check the
HTTP status code of the response. If a response is received, this should be
considered a good test, even if an error has occurred. No parameters are passed
to the API endpoints. An <code>OK</code> will be displayed if a test passes, and a <code>FAIL</code>
will be displayed with an HTTP/curl code if a test fails.</p>
<h2 id="adding-future-endpoints"><a class="header" href="#adding-future-endpoints">Adding Future Endpoints</a></h2>
<p>Endpoints in the script <code>./scripts/smoke_test.sh</code> are stored in an array
identified as <code>RPC_ENDPOINTS</code>.</p>
<p>Add the endpoint identifier minus the prefix <code>Forest</code> to the module that it
belongs to (ie gas, net, state, etc) or add a new section if a new API is added.</p>
<p>This should be checked during the review process if new API methods are added to
keep this script and test suite up to date.</p>
<div style="break-before: page; page-break-before: always;"></div><p>It's unclear how we can support migrations without adding a lot of code
complexity. This document is meant to shed light on the matter and illuminate a
sustainable path forward. As a start we will consider a migration going from
nv15 to nv16.</p>
<h1 id="migration-path-investigation-from-nv15-to-nv16"><a class="header" href="#migration-path-investigation-from-nv15-to-nv16">Migration path investigation from nv15 to nv16</a></h1>
<h2 id="findings"><a class="header" href="#findings">Findings</a></h2>
<ol>
<li>Actor IDs definitely changed</li>
</ol>
<p>For following actors only their CID have changed:</p>
<ul>
<li>init</li>
<li>cron</li>
<li>account</li>
<li>power</li>
<li>miner</li>
<li>paymentchannel</li>
<li>multisig</li>
<li>reward</li>
<li>verifiedregistry</li>
</ul>
<p>Those are just simple code migration.</p>
<p>For system and market actors there's both code and state changes. That's why
there is dedicated logic for their migration.</p>
<p>The system actor need to update the state tree with its new state that holds now
the <code>ManifestData</code> CID.</p>
<p>For the market actor more work is involved to upgrade actor state due to support
for UTF-8 string label encoding in deal proposals and pending proposals (see
<a href="https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0027.md">FIP-0027</a>).</p>
<ol start="2">
<li>Some gas calculations changed?</li>
</ol>
<p>I don't think we are concerned by this. Gas metering can change at a given
protocol upgrade for one or many actors but the impact is irrelevant as it
doesn't modify blockchain data structures. Gas calculations should only impact
code and in our case the nv16 ref-fvm is already supporting the new gas changes.</p>
<ol start="3">
<li>drand calculation changed?</li>
</ol>
<p>Ditto.</p>
<ol start="4">
<li>What else changed?</li>
</ol>
<p>Nothing else as far I can see.</p>
<h2 id="open-questions"><a class="header" href="#open-questions">Open questions</a></h2>
<ul>
<li>
<p>pre-migration framework + caching: how much do we need a similar approach in
Forest? Are there other alternatives? We can definitely skip this part at
first. For information the old nv12 state migration in forest took around
13-15 secs.</p>
</li>
<li>
<p>Seen in Lotus: <code>UpgradeRefuelHeight</code>. What's Refuel for?</p>
</li>
<li>
<p>Migration logic is in spec-actors (go actors), what the future of this given
clients moved to builtin-actors (rust actors) and ref-fvm? In an ideal world
we might want a shared migration logic.</p>
</li>
<li>
<p>Implement Lite migration?</p>
<blockquote>
<p>should allow for easy upgrades if actors code needs to change but state does
not. Example provided above the function to perform all the migration
duties. Check actors_version_checklist.md for the rest of the steps.</p>
</blockquote>
</li>
<li>
<p>What are non-deferred actors in the context of a migration?</p>
</li>
<li>
<p>The <code>migrationJobResult</code> struct is using a <code>states7</code> actor instead of a
<code>states8</code> one (in go spec-actors). Typo or are there some good reasons?</p>
</li>
</ul>
<h2 id="changes-rough-proposal"><a class="header" href="#changes-rough-proposal">Changes rough proposal</a></h2>
<p>To support nv15 to nv16 migration we need to:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Make forest sync again on nv15 and be able to support multiple network
versions.</li>
<li><input disabled="" type="checkbox"/>
Understand existing forest migration framework (used in the past for nv12
migration). Can we reuse most of the code as is?</li>
<li><input disabled="" type="checkbox"/>
Implementation of the nv16 migration logic (replicating same logic as in
spec-actors).</li>
<li><input disabled="" type="checkbox"/>
Implementation of unit tests covering this migration.</li>
<li><input disabled="" type="checkbox"/>
Implementation of a migration schedule that will select the right
migration path.</li>
<li><input disabled="" type="checkbox"/>
Test migration using the exported calibnet and mainnet snapshots and
respectively measure the elapsed time and memory usage.</li>
</ul>
<h2 id="test-snapshots"><a class="header" href="#test-snapshots">Test snapshots</a></h2>
<p>For testing a calibnet migration two snapshots have been exported with Lotus:</p>
<ul>
<li>lotus_snapshot_2022-Aug-5_height_1044460.car</li>
<li>lotus_snapshot_2022-Aug-5_height_1044659.car</li>
</ul>
<p>They are respectively exported 200 and 1 epochs before the Skyr upgrade (the 200
version could be useful if we decide to implement a pre-migration like in
Lotus).</p>
<p>For testing a mainnet migration, one snapshot has been retrieved from Protocol
Labs s3 bucket using the <a href="https://github.com/kasteph/lily-shed/">lily-shed</a>
util:</p>
<ul>
<li>minimal_finality_stateroots_1955760_2022-07-05_00-00-00.car</li>
</ul>
<p>This one is 4560 epochs before. If needed we can extract closer snapshots later.</p>
<p>Those snapshots have been uploaded to our Digital Ocean Spaces.</p>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional resources</a></h2>
<p><code>what changed</code> between versions is maintained in the
<a href="https://github.com/filecoin-project/tpm/tree/master/Network%20Upgrades">tpm repo</a>,
e.g. all the changes in
<a href="https://github.com/filecoin-project/tpm/blob/master/Network%20Upgrades/v16.md">NV15 -&gt; NV16</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="state-migration-guide-"><a class="header" href="#state-migration-guide-">State migration guide ⏩</a></h2>
<p>This guide is intended to help to implement new state migration in the future.
It will be based on the current state migration implementation for NV18 and
NV19.</p>
<h3 id="state-migration-requirements"><a class="header" href="#state-migration-requirements">State migration requirements</a></h3>
<ul>
<li>The proper actor bundle is released for at least the test network. It should
be available on the
<a href="https://github.com/filecoin-project/builtin-actors/releases">actor bundles repository</a>.
You can verify which upgrade needs which bundle in the
<a href="https://github.com/filecoin-project/core-devs/tree/master/Network%20Upgrades">network upgrade matrix</a>.</li>
<li>The state migration should be implemented in the
<a href="https://github.com/filecoin-project/go-state-types/tree/master/builtin">Go library</a>.
This is the source of truth for the state migration. Also, we should carefully
analyze the FIPs and implement the migration based on them. In case of doubt,
we should always consider the FIPs as the source of truth and reach out to the
Lotus team if we find potential issues in their implementation.</li>
</ul>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<h4 id="import-the-actor-bundle"><a class="header" href="#import-the-actor-bundle">Import the actor bundle</a></h4>
<p>The first step is to import the actor bundle into Forest. This is done by:</p>
<ul>
<li>adding the bundle to the <code>HeightInfos</code> struct in the network definitions files
(e.g.,
<a href="https://github.com/ChainSafe/forest/blob/main/networks/src/calibnet/mod.rs">calibnet</a>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HeightInfo {
    height: Height::Hygge,
    epoch: 322_354,
    bundle: Some(ActorBundleInfo {
        manifest: Cid::try_from(&quot;bafy2bzaced25ta3j6ygs34roprilbtb3f6mxifyfnm7z7ndquaruxzdq3y7lo&quot;).unwrap(),
        url: Url::parse(&quot;https://github.com/filecoin-project/builtin-actors/releases/download/v10.0.0-rc.1/builtin-actors-calibrationnet.car&quot;).unwrap()
})
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Adding the download at the proper height to the <code>load_bundles</code> function in the
<a href="https://github.com/ChainSafe/forest/blob/main/forest/daemon/src/bundle/mod.rs">daemon</a>.
This step could be potentially done automatically in the future.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if epoch &lt; config.chain.epoch(Height::Hygge) {
    bundles.push(get_actors_bundle(config, Height::Hygge).await?);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implement-the-migration"><a class="header" href="#implement-the-migration">Implement the migration</a></h3>
<p>The next step is to implement the migration itself. In this guide, we will take
the <code>translate Go code into Rust</code> approach. It's not the cleanest way to do it,
but it's the easiest. Note that the Forest state migration design is not the
same as the Lotus one (we tend to avoid code duplications), so we must be
careful when translating the code.</p>
<h4 id="create-the-migration-module"><a class="header" href="#create-the-migration-module">Create the migration module</a></h4>
<p>Create the migration module in the
<a href="https://github.com/ChainSafe/forest/tree/main/vm/state_migration/src">state migration crate</a>.
A valid approach is just to copy-paste the previous migration module and modify
it accordingly. The files that will most likely be present:</p>
<ul>
<li><code>mod.rs</code>: here we bundle our migration modules and export the final migration
function,</li>
<li><code>system.rs</code>: here we define the system actor migration logic which (so far)
seems to not change between upgrades,</li>
<li><code>migration.rs</code>: the heart of the migration. Here we add the migration logic
for each actor. Its Go equivalent is the
<a href="https://github.com/filecoin-project/go-state-types/blob/master/builtin/v10/migration/top.go">top.go</a>,
in case of NV18,</li>
<li><code>verifier.rs</code>: checks for the migration definition.</li>
</ul>
<p>We will most likely need as many custom migrators as there are in the Go
implementation. In other terms, if you see that the Go
<a href="https://github.com/filecoin-project/go-state-types/tree/master/builtin/v10/migration">migration</a>
contains:</p>
<ul>
<li><code>eam.go</code> - Ethereum Account Manager migration,</li>
<li><code>init.go</code> - Init actor migration,</li>
<li><code>system.go</code> - System actor migration,</li>
</ul>
<p>Then our implementation will need to define those as well.</p>
<h4 id="the-actual-migration"><a class="header" href="#the-actual-migration">The actual migration</a></h4>
<p>This part will largely depend on the complexity of the network upgrade itself.
The goal is to translate the <code>MigrateStateTree</code> method from
<a href="https://github.com/filecoin-project/go-state-types/blob/master/builtin/v10/migration/top.go#L28">Go</a>
to the <code>add_nvXX_migrations</code> in the <code>migration.rs</code> file. The
<code>add_nvXX_migrations</code> method is responsible for adding all the migrations that
are needed for the network upgrade and the logic in between. Note that the
Forest version is much simpler as it doesn't contain the migration <code>engine</code>
(implemented in the base module).</p>
<p>The first thing to do is to get the current system actor state and the current
manifest. Then we will map the old actor codes to the new ones.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let state_tree = StateTree::new_from_root(store.clone(), state)?;
let system_actor = state_tree
    .get_actor(&amp;Address::new_id(0))?
    .ok_or_else(|| anyhow!(&quot;system actor not found&quot;))?;

let system_actor_state = store
    .get_obj::&lt;SystemStateV10&gt;(&amp;system_actor.state)?
    .ok_or_else(|| anyhow!(&quot;system actor state not found&quot;))?;
let current_manifest_data = system_actor_state.builtin_actors;
let current_manifest = Manifest::load(&amp;store, &amp;current_manifest_data, 1)?;

let (version, new_manifest_data): (u32, Cid) = store
    .get_cbor(new_manifest)?
    .ok_or_else(|| anyhow!(&quot;new manifest not found&quot;))?;
let new_manifest = Manifest::load(&amp;store, &amp;new_manifest_data, version)?;

<span class="boring">}</span></code></pre></pre>
<p>⚠️ Stay vigilant! The <code>StateTree</code> versioning is independent of the network and
actor versioning. At the time of writing, the following holds:</p>
<ul>
<li><code>StateTreeVersion0</code> - Actors version &lt; v2</li>
<li><code>StateTreeVersion1</code> - Actors version v2</li>
<li><code>StateTreeVersion2</code> - Actors version v3</li>
<li><code>StateTreeVersion3</code> - Actors version v4</li>
<li><code>StateTreeVersion4</code> - Actors version v5 up to v9</li>
<li><code>StateTreeVersion5</code> - Actors version v10 and above These are not compatible
with each other and when using a new FVM, we can only use the latest one.</li>
</ul>
<p>For actors that don't need any state migration, we can use the <code>nil_migrator</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>current_manifest.builtin_actor_codes().for_each(|code| {
let id = current_manifest.id_by_code(code);
let new_code = new_manifest.code_by_id(id).unwrap();
self.add_migrator(*code, nil_migrator(*new_code));
});

For each actor with non-trivial migration logic, we add the migration function. For example, for the `init` actor, we have:
```rust
self.add_migrator(
*current_manifest.get_init_code(),
init::init_migrator(*new_manifest.get_init_code()),
);
<span class="boring">}</span></code></pre></pre>
<p>and we define the <code>init_migrator</code> in a separate module. This logic may include
setting some defaults on the new fields, changing the current ones to an
upgraded version and so on.</p>
<h4 id="verifier"><a class="header" href="#verifier">Verifier</a></h4>
<p>An optional (but recommended) piece of code that performs some sanity checks on
the state migration definition. At the time of writing, it checks that all
builtin actors are assigned a migration function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let verifier = Arc::new(Verifier::default());
<span class="boring">}</span></code></pre></pre>
<h4 id="post-migration-actions"><a class="header" href="#post-migration-actions">Post-migration actions</a></h4>
<p>Some code, like creating an entirely new actor (in the case of NV18 creating EAM
and Ethereum Account actors), needs to be executed post-migration. This is done
in the post-migration actions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let post_migration_actions = [create_eam_actor, create_eth_account_actor]
    .into_iter()
    .map(|action| Arc::new(action) as PostMigrationAction&lt;DB&gt;)
    .collect();
<span class="boring">}</span></code></pre></pre>
<h4 id="creating-the-migration-object-and-running-it"><a class="header" href="#creating-the-migration-object-and-running-it">Creating the migration object and running it</a></h4>
<p>We take all the migrations that we have defined previously, all the
post-migration actions, and create the migration object.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut migration = StateMigration::&lt;DB&gt;::new(Some(verifier), post_migration_actions);
migration.add_nv18_migrations(blockstore.clone(), state, &amp;new_manifest_cid)?;

let actors_in = StateTree::new_from_root(blockstore.clone(), state)?;
let actors_out = StateTree::new(blockstore.clone(), StateTreeVersion::V5)?;
let new_state =
migration.migrate_state_tree(blockstore.clone(), epoch, actors_in, actors_out)?;

Ok(new_state)
<span class="boring">}</span></code></pre></pre>
<p>The new state is the result of the migration.</p>
<h3 id="use-the-migration"><a class="header" href="#use-the-migration">Use the migration</a></h3>
<p>After completing the migration, we need to invoke it at the proper height. This
is done in the <code>handle_state_migrations</code> method in the
<a href="https://github.com/ChainSafe/forest/blob/main/blockchain/state_manager/src/lib.rs">state manager</a>.
This step could be potentially done automatically in the future.</p>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>We currently lack a framework for properly testing the network upgrades before
they actually happen. This should change in the future.</p>
<p>For now, we can do it using a snapshot generated after the network upgrade,
e.g., 100 epochs after and validating previous epochs which should include the
upgrade height.</p>
<pre><code class="language-shell">forest --chain calibnet --encrypt-keystore false --halt-after-import --height=-200 --import-snapshot &lt;SNAPSHOT&gt;
</code></pre>
<h3 id="future-considerations"><a class="header" href="#future-considerations">Future considerations</a></h3>
<ul>
<li>Testing without the need for a snapshot or a running node. This would allow us
to test the network upgrade in a more isolated way. See how it is done in the
<a href="https://github.com/filecoin-project/go-state-types/blob/master/builtin/v9/migration/test/migration_test.go">Go library</a>.</li>
<li>Grab the actor bundles from the IPFS. This would make Forest less dependent on
the Github infrastructure.
<a href="https://github.com/ChainSafe/forest/issues/2765">Issue #2765</a></li>
<li>Consider pre-migrations as Lotus does. It is not needed at the moment (the
mainnet upgrade takes several seconds at most) but may become a bottleneck if
the migration is too heavy.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="state-migration-spike-"><a class="header" href="#state-migration-spike-">State migration spike 🛂</a></h2>
<h3 id="what-is-state-migration"><a class="header" href="#what-is-state-migration">What is state migration?</a></h3>
<p>State migration is a process where the <code>StateTree</code> contents are transformed from
an older form to a newer form. Certain Actors may need to be created or migrated
as well.</p>
<h3 id="why-do-we-need-to-migrate"><a class="header" href="#why-do-we-need-to-migrate">Why do we need to migrate?</a></h3>
<p>Migration is required when the structure of the state changes. This happens when
new fields are added or existing ones are modified. Migration is <strong>not</strong>
required in case of new behaviour.</p>
<p>In case of NV18, the <code>StateTree</code> changed from version 4 to version 5. See
https://github.com/filecoin-project/ref-fvm/pull/1062</p>
<h3 id="what-to-upgrade"><a class="header" href="#what-to-upgrade">What to upgrade?</a></h3>
<p>We need to upgrade the <code>StateTree</code> which is represented as
<code>HAMT&lt;Cid, ActorState&gt;</code> to the latest version.</p>
<p>On top of that, we need to migrate certain actors. In the case of NV18 upgrade,
it's the
<a href="https://github.com/filecoin-project/go-state-types/blob/d8fdbda2ad86de55bcde7f567c6da9c5f430c7a1/builtin/v10/migration/init.go#L32">init</a>
and
<a href="https://github.com/filecoin-project/go-state-types/blob/master/builtin/v10/migration/system.go#L24">system</a>
actor.
<a href="https://github.com/filecoin-project/go-state-types/blob/master/builtin/v10/migration/eam.go">EAM</a>
actor needs to be created.</p>
<h3 id="when-to-upgrade"><a class="header" href="#when-to-upgrade">When to upgrade?</a></h3>
<p>There is a separate upgrade schedule for each network. In Lotus, it is defined
in
<a href="https://github.com/filecoin-project/lotus/blob/dbbcf4b2ee9626796e23a096c66e67ff350810e4/chain/consensus/filcns/upgrades.go#L83">upgrades.go</a>.
In Venus, in
<a href="https://github.com/filecoin-project/venus/blob/master/pkg/fork/fork.go">fork.go</a>
which has the same structure.</p>
<p>For the case of NV18, it is defined as</p>
<pre><code class="language-go">Height:    build.UpgradeHyggeHeight,
Network:   network.Version18,
Migration: UpgradeActorsV10,
PreMigrations: []stmgr.PreMigration{{
	PreMigration:    PreUpgradeActorsV10,
	StartWithin:     60,
	DontStartWithin: 10,
	StopWithin:      5,
}},
Expensive: true,
</code></pre>
<h3 id="how-to-upgrade"><a class="header" href="#how-to-upgrade">How to upgrade?</a></h3>
<p>Iterate over the state of each actor at the given epoch and write the new state
along with any specific changes to the respective state. This involves iterating
over each of the HAMT nodes storing the state and writing them to the database.</p>
<p><a href="https://github.com/filecoin-project/lotus/blob/58900a70333a11a903cf9fe3f29e6a5c309cb000/chain/consensus/filcns/upgrades.go#L1591-L1612">Lotus upgrade method</a>
and the
<a href="https://github.com/filecoin-project/go-state-types/tree/master/builtin/v10/migration">module</a>
dedicated to Actors <code>v10</code> migration. The core logic is
<a href="https://github.com/filecoin-project/go-state-types/blob/master/builtin/v10/migration/top.go#L28">here</a>.
The same module is used by Venus.</p>
<p>Forks migrations: handled by
<a href="https://github.com/filecoin-project/lotus/blob/58900a70333a11a903cf9fe3f29e6a5c309cb000/chain/stmgr/forks.go#L42-L53">fork.go</a>
entities.</p>
<h3 id="where-to-upgrade"><a class="header" href="#where-to-upgrade">Where to upgrade?</a></h3>
<p>It should be done most likely in the apply blocks method.</p>
<p><a href="https://github.com/filecoin-project/lotus/blob/74d94af03418c799350fc0f40d3758c23cd82ab8/chain/consensus/compute_state.go#L178">Lotus</a>:</p>
<pre><code class="language-go">// handle state forks
// XXX: The state tree
pstate, err = sm.HandleStateForks(ctx, pstate, i, em, ts)
if err != nil {
	return cid.Undef, cid.Undef, xerrors.Errorf(&quot;error handling state forks: %w&quot;, err)
}
</code></pre>
<p>In
<a href="https://github.com/ChainSafe/forest/blob/main/blockchain/state_manager/src/lib.rs#L421-L424">Forest</a>
we already have a hint from the past:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if epoch_i == turbo_height {
    todo!(&quot;cannot migrate state when using FVM - see https://github.com/ChainSafe/forest/issues/1454 for updates&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>We can try with something simplistic to get it running, it's not an issue.
Afterwards we can implement a proper schedule with functors.</p>
<h3 id="challenges"><a class="header" href="#challenges">Challenges</a></h3>
<ul>
<li>Doing the state migration efficiently; we need to traverse every entry in the
state trie. Lotus does pre-migration which are filling relevant caches to
speed up the eventual full migration at the upgrade epoch. We might need to do
something like this as well; it might not be necessary for the first
iteration - depends on how performant the migration process would be in the
Forest itself.</li>
<li>No test network. While we can use existing snapshots from before the upgrade
to test state migration, it is not sustainable if we want to continuously
support calibration network. We either require a local devnet for testing
migration <strong>before</strong> they actually happen on real networks or we can try
supporting more bleeding-edge networks. The former approach is more solid, but
the latter might be easier to implement at first (and would give Forest more
testnets support which is always welcome).</li>
<li>There may be forks, so we probably need to keep the pre-migration and
post-migration state in two caches for some back and forths. This in Lotus is
handled with
<a href="https://github.com/filecoin-project/lotus/blob/f641139bf237e6e955a9a2f33cfc05ba52430b1b/chain/stmgr/forks.go#L175">HandleStateForks</a>.</li>
<li>For EAM Actor we may need some Ethereum methods we have not yet implemented.
Perhaps what <code>builtin-actors</code> and <code>ref-fvm</code> expose will be enough.</li>
</ul>
<h3 id="current-forest-implementation"><a class="header" href="#current-forest-implementation">Current Forest implementation</a></h3>
<p>For the moment Forest does not support migrations. The
<a href="https://github.com/ChainSafe/forest/blob/state-migration-spike/vm/state_migration/src/lib.rs">code</a>
that was meant for this is not used at the moment. Most probably we will be able
to utilise it.</p>
<h3 id="plan"><a class="header" href="#plan">Plan</a></h3>
<p>We should start by adding an <code>nv18</code> to the state migration
<a href="https://github.com/ChainSafe/forest/tree/state-migration-spike/vm/state_migration/src">crate</a>,
along the lines of the
<a href="https://github.com/filecoin-project/go-state-types/blob/master/builtin/v10/migration/init.go">Go equivalent</a>.
Most likely this would mean adding some missing structures, related to the <code>v10</code>
actors (Ethereum ones).</p>
<p>Then try to plug it in
<a href="https://github.com/ChainSafe/forest/blob/main/blockchain/state_manager/src/lib.rs#L421-L424">apply_blocks</a>.
This may work for calibration network. Afterwards, we will most likely need to
iterate to achieve acceptable performance for mainnet. Some ideas on how to
achieve this can be taken from Lotus/Venus, e.g., pre-migration caching.</p>
<h3 id="sources"><a class="header" href="#sources">Sources</a></h3>
<ul>
<li>Rahul's article: https://hackmd.io/@tbdrqGmwSXiPjxgteK3hMg/r1D6cVM_u</li>
<li>Lotus codebase - https://github.com/filecoin-project/lotus</li>
<li>Venus codebase - https://github.com/filecoin-project/venus</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forest-test-plan"><a class="header" href="#forest-test-plan">Forest Test Plan</a></h1>
<pre><code>Version: 1.0
Author: David Himmelstrup
Date updated: 2022-11-14
</code></pre>
<h2 id="test-objective"><a class="header" href="#test-objective">Test objective:</a></h2>
<p>The Filecoin specification is complex and changes rapidly over time. To manage
this complexity, Forest uses a rigorous testing framework, starting with
individual functions and ending with complete end-to-end validation. The goals,
in descending order of priority, are:</p>
<ul>
<li><strong>Regression detection.</strong> If Forest can no longer connect to mainnet or if any
of its features break, the development team should be automatically notified.</li>
<li><strong>No institutional/expert knowledge required.</strong> Developers can work on a
Forest subsystem without worrying about accidentally breaking a different
subsystem.</li>
<li><strong>Bug identification.</strong> If something break, the test data should narrow down
the location of the issue.</li>
</ul>
<h2 id="scope-of-testing-definition"><a class="header" href="#scope-of-testing-definition">Scope of testing definition:</a></h2>
<p>Forest testing is multifaceted and layered. The testing pipeline looks like
this:</p>
<ul>
<li><strong>Unit tests for library functions.</strong> Example: parsing a network version fails
for garbled input.</li>
<li><strong>Unit tests for CLI programs.</strong> Example: <code>forest-cli dump</code> produces a valid
configuration.</li>
<li><strong>Property tests.</strong> Example: <code>deserialize ∘ serialize = id</code> for all custom
formats.</li>
<li><strong>Network synchronization.</strong> PRs are checked against the calibration network,
the main branch is checked against the main network.</li>
<li><strong>End-to-end feature tests.</strong> Example: Network snapshots are generated daily
and hosted publicly.</li>
<li><strong>Link checking.</strong> API documentation and markdown files are checked for dead
links.</li>
<li><strong>Spell checking.</strong> API documentation is checked for spelling errors and
typos.</li>
</ul>
<p>All testing is automated and there are no additional manual checks required for
releases.</p>
<h2 id="resources--roles--responsibilities"><a class="header" href="#resources--roles--responsibilities">Resources / Roles &amp; Responsibilities:</a></h2>
<p>Testing is a team effort and everyone is expected to add unit tests, property
tests, or integration tests as part of their PR contributions.</p>
<h2 id="tools-description"><a class="header" href="#tools-description">Tools description:</a></h2>
<ul>
<li>Bug tracker: https://github.com/ChainSafe/forest/issues</li>
<li>Test Automation tools: <a href="https://nexte.st/">nextest</a>,
<a href="https://docs.rs/quickcheck/latest/quickcheck/">quickcheck</a></li>
<li>Languages: <a href="https://www.rust-lang.org/">Rust</a></li>
<li>CI/CD: <a href="https://github.com/ChainSafe/forest/actions">GitHub Actions</a></li>
<li>Version control: <a href="https://git-scm.com/">Git</a></li>
</ul>
<h2 id="deliverables"><a class="header" href="#deliverables">Deliverables:</a></h2>
<p>The only deliverable is a green checkmark. Either all tests pass and a PR may be
merged into the main branch or something is not up to spec and the PR is
blocked.</p>
<h2 id="test-environment--ci"><a class="header" href="#test-environment--ci">Test Environment &amp; CI</a></h2>
<p>Short-running tests are executed via GitHub Actions on Linux and MacOS.
Long-running tests are run on dedicated testing servers.</p>
<p>The services on the dedicated servers are described here:
https://github.com/ChainSafe/forest-iac</p>
<p>In short, the long-running tests are executed in dockerized environments with
some running one per day and some running on every commit to the main Forest
branch. At the moment, the tests are run on DigitalOcean but they can be run
from anywhere. Feedback is reported to ChainSafe's Slack server and artifacts
are uploaded to DigitalOcean Spaces.</p>
<h2 id="test-data"><a class="header" href="#test-data">Test Data:</a></h2>
<p>No private or confidential data is involved in testing. Everything is public.</p>
<h2 id="bug-template"><a class="header" href="#bug-template">Bug template:</a></h2>
<p>Bug report template is available on GitHub:
https://github.com/ChainSafe/forest/blob/main/.github/ISSUE_TEMPLATE/bug_report.md</p>
<p>The template is applied automatically when bugs are reported through GitHub.</p>
<h2 id="risk--issues"><a class="header" href="#risk--issues">Risk &amp; Issues:</a></h2>
<ul>
<li>We depend on the calibration network for testing. If this network is down, our
testing capabilities are degraded.</li>
<li>We depend on GitHub Actions for testing. If GitHub Action is unavailable,
testing will be degraded.</li>
<li>Testing against mainnet is effective for discovering issues, but not great for
identifying root causes. Finding bugs <em>before</em> syncing to mainnet is always to
be preferred.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cleaning"><a class="header" href="#cleaning">Cleaning</a></h1>
<pre><code>rm -rf ~/.genesis-sectors/ ~/.lotus-local-net/ ~/.lotus-miner-local-net/
</code></pre>
<h1 id="running-the-node"><a class="header" href="#running-the-node">Running the node:</a></h1>
<pre><code>export LOTUS_PATH=~/.lotus-local-net
export LOTUS_MINER_PATH=~/.lotus-miner-local-net
export LOTUS_SKIP_GENESIS_CHECK=_yes_
export CGO_CFLAGS_ALLOW=&quot;-D__BLST_PORTABLE__&quot;
export CGO_CFLAGS=&quot;-D__BLST_PORTABLE__&quot;
make 2k
./lotus fetch-params 2048
./lotus-seed pre-seal --sector-size 2KiB --num-sectors 2
./lotus-seed genesis new localnet.json
./lotus-seed genesis add-miner localnet.json ~/.genesis-sectors/pre-seal-t01000.json
./lotus daemon --lotus-make-genesis=devgen.car --genesis-template=localnet.json --bootstrap=false
# Keep this terminal open
</code></pre>
<h1 id="running-the-miner"><a class="header" href="#running-the-miner">Running the miner:</a></h1>
<pre><code>export LOTUS_PATH=~/.lotus-local-net
export LOTUS_MINER_PATH=~/.lotus-miner-local-net
export LOTUS_SKIP_GENESIS_CHECK=_yes_
export CGO_CFLAGS_ALLOW=&quot;-D__BLST_PORTABLE__&quot;
export CGO_CFLAGS=&quot;-D__BLST_PORTABLE__&quot;
./lotus wallet import --as-default ~/.genesis-sectors/pre-seal-t01000.key
./lotus-miner init --genesis-miner --actor=t01000 --sector-size=2KiB --pre-sealed-sectors=~/.genesis-sectors --pre-sealed-metadata=~/.genesis-sectors/pre-seal-t01000.json --nosync
./lotus-miner run --nosync
# Keep this terminal open
</code></pre>
<h1 id="helpers-1"><a class="header" href="#helpers-1">Helpers:</a></h1>
<pre><code>./lotus-miner info
./lotus-miner sectors list
</code></pre>
<h1 id="send-data-to-miner"><a class="header" href="#send-data-to-miner">Send data to miner:</a></h1>
<pre><code>./lotus client query-ask t01000
./lotus client import LICENSE-APACHE
./lotus client deal
./lotus client retrieve [CID from import] test.txt # data has to be on chain first
</code></pre>
<h1 id="get-data-on-chain"><a class="header" href="#get-data-on-chain">Get data on chain:</a></h1>
<pre><code>./lotus-miner storage-deals pending-publish --publish-now
./lotus-miner sectors seal 2
./lotus-miner sectors batching precommit --publish-now
./lotus-miner sectors batching commit --publish-now
</code></pre>
<h1 id="retrieve"><a class="header" href="#retrieve">Retrieve:</a></h1>
<pre><code>./lotus client local
./lotus client retrieve --provider t01000 [CID from import] outputfile.txt
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
